

prompt_templates = {
            "Standardowy": {
                "template": (
                    "**Jako analityk z 10 letnim stażem i doświadczeniem w notacji PlantUML przygotuj diagram {diagram_type} w notacji PlantUML dla procesu:**\n\n"
                    "{process_description}\n\n"
                    "**Wymagania:**\n"
                    "- Format: Kompletny kod PlantUML (@startuml ... @enduml)\n"
                    "- Uwzględnij wszystkich uczestników procesu\n"
                    "- Zachowaj logiczną sekwencję kroków\n\n"
                    "**Output:** Gotowy kod PlantUML"
                ),
                "allowed_diagram_types": "all",  # lub lista np. ["sequence", "activity", ...]
                "type": "PlantUML"
            },
            "Diagram sekwencji": {
                "template": (
                    "Na podstawie opisu procesu biznesowego: {process_description}\n\n"

                    "**KROK 1: ANALIZA PROCESU BIZNESOWEGO**\n"
                    "Przeanalizuj opisany proces i zidentyfikuj:\n"
                    "- Kto inicjuje proces (główny aktor)?\n"
                    "- Jakie są kolejne kroki procesu w porządku chronologicznym?\n"
                    "- Które role/systemy uczestniczą w każdym kroku?\n"
                    "- Jakie dane są przekazywane między uczestnikami?\n"
                    "- Gdzie występują decyzje/warunki w procesie?\n"
                    "- Jakie są alternatywne ścieżki (błędy, wyjątki)?\n"
                    "- Czy występują operacje asynchroniczne lub równoległe?\n"
                    "- Gdzie proces się kończy dla różnych scenariuszy?\n\n"

                    "**KROK 2: IDENTYFIKACJA UCZESTNIKÓW SEKWENCJI**\n"
                    "Na podstawie analizy określ wszystkich uczestników procesu:\n\n"

                    "**A) AKTORZY LUDZCY:**\n"
                    "- Kto jest inicjatorem procesu?\n"
                    "- Kto podejmuje decyzje w trakcie procesu?\n"
                    "- Kto otrzymuje rezultaty/powiadomienia?\n"
                    "- Czy są różne role z różnymi uprawnieniami?\n\n"

                    "**B) SYSTEMY WEWNĘTRZNE:**\n"
                    "- Jakie aplikacje/serwisy obsługują proces?\n"
                    "- Które komponenty komunikują się ze sobą?\n"
                    "- Jakie bazy danych są wykorzystywane?\n"
                    "- Czy są systemy do powiadomień/raportowania?\n\n"

                    "**C) SYSTEMY ZEWNĘTRZNE:**\n"
                    "- Z jakimi zewnętrznymi API trzeba się komunikować?\n"
                    "- Które systemy dostarczają dane referencyjne?\n"
                    "- Jakie systemy otrzymują powiadomienia?\n"
                    "- Czy są systemy płatnicze/weryfikacyjne?\n\n"

                    "**D) KOMPONENTY INFRASTRUKTURALNE:**\n"
                    "- Czy są kolejki komunikatów?\n"
                    "- Czy są serwisy cache/storage?\n"
                    "- Czy są bramy API?\n"
                    "- Czy są serwisy audytu/logowania?\n\n"

                    "**KROK 3: MAPOWANIE KROKÓW PROCESU NA INTERAKCJE**\n"
                    "Dla każdego kroku procesu biznesowego określ:\n\n"

                    "**A) GŁÓWNY PRZEPŁYW (HAPPY PATH):**\n"
                    "- Kto inicjuje każdy krok?\n"
                    "- Do kogo/czego jest wysyłana wiadomość?\n"
                    "- Jaki jest typ komunikacji (synchroniczna/asynchroniczna)?\n"
                    "- Jakie dane są przekazywane?\n"
                    "- Czy są zwracane odpowiedzi/potwierdzenia?\n\n"

                    "**B) PRZEPŁYWY WARUNKOWE:**\n"
                    "- Gdzie występują warunki if/else?\n"
                    "- Jakie są kryteria decyzyjne?\n"
                    "- Jak różnią się ścieżki dla różnych warunków?\n\n"

                    "**C) PRZEPŁYWY BŁĘDÓW:**\n"
                    "- Co dzieje się przy błędach walidacji?\n"
                    "- Jak obsługiwane są błędy systemowe?\n"
                    "- Czy są mechanizmy retry/kompensacji?\n\n"

                    "**D) OPERACJE RÓWNOLEGŁE:**\n"
                    "- Które operacje mogą być wykonywane jednocześnie?\n"
                    "- Gdzie są punkty synchronizacji?\n"
                    "- Czy są operacje asynchroniczne w tle?\n\n"

                    "**KROK 4: GENEROWANIE DIAGRAMU PlantUML**\n"
                    "Wygeneruj kompletny kod PlantUML w podstawowej notacji z następującymi wymaganiami:\n\n"

                    "**STRUKTURA TECHNICZNA:**\n"
                    "1. **Rozpocznij:** `@startuml`\n"
                    "2. **Tytuł:** `title [Nazwa Procesu] - Sekwencja Interakcji`\n"
                    "3. **Definicje uczestników przed sekwencją**\n"
                    "4. **Logiczna kolejność interakcji**\n"
                    "5. **Zakończ:** `@enduml`\n\n"

                    "**UCZESTNICY DO UŻYCIA:**\n"
                    "- `actor \"Nazwa\" as alias` - użytkownicy/role biznesowe\n"
                    "- `participant \"Nazwa\" as alias` - systemy/aplikacje wewnętrzne\n"
                    "- `entity \"Nazwa\" as alias` - bazy danych/storage\n"
                    "- `boundary \"Nazwa\" as alias` - interfejsy/API\n"
                    "- `control \"Nazwa\" as alias` - kontrolery/serwisy\n"
                    "- `collections \"Nazwa\" as alias` - kolekcje/listy danych\n"
                    "- `queue \"Nazwa\" as alias` - kolejki komunikatów\n"
                    "- `database \"Nazwa\" as alias` - systemy zewnętrzne\n\n"

                    "**TYPY STRZAŁEK I KOMUNIKACJI:**\n"
                    "- `->` - wywołanie synchroniczne\n"
                    "- `-->` - odpowiedź synchroniczna\n"
                    "- `->>` - wywołanie asynchroniczne\n"
                    "- `-->>` - odpowiedź asynchroniczna\n"
                    "- `-x` - wywołanie zakończone błędem\n"
                    "- `--x` - odpowiedź z błędem\n\n"

                    "**ELEMENTY KONTROLI PRZEPŁYWU:**\n"
                    "- `alt [warunek]` / `else [warunek]` / `end` - warunki\n"
                    "- `opt [warunek]` / `end` - opcjonalne operacje\n"
                    "- `loop [warunek]` / `end` - pętle\n"
                    "- `par` / `and` / `end` - operacje równoległe\n"
                    "- `critical` / `end` - sekcje krytyczne\n"
                    "- `break [warunek]` / `end` - przerwanie sekwencji\n\n"

                    "**DODATKOWE ELEMENTY:**\n"
                    "- `activate alias` / `deactivate alias` - aktywacja uczestnika\n"
                    "- `note left/right/over alias : tekst` - notatki wyjaśniające\n"
                    "- `ref over alias1, alias2 : Nazwa procesu` - referencje do pod-procesów\n"
                    "- `group [nazwa grupy]` / `end` - grupowanie logiczne\n"
                    "- `|||` - przerwa czasowa\n"
                    "- `... tekst ...` - przerwa z opisem\n\n"

                    "**PRZYKŁAD STRUKTURY:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "title [Nazwa Procesu] - Sekwencja Interakcji\n\n"

                    "' Uczestnicy procesu\n"
                    "actor \"[Rola Inicjująca]\" as user\n"
                    "boundary \"[Proces] Web Interface\" as web\n"
                    "control \"[Proces] Controller\" as controller\n"
                    "control \"[Function] Service\" as service\n"
                    "entity \"[Proces] Repository\" as repo\n"
                    "database \"[Proces] Database\" as db\n"
                    "participant \"[External] System\" as external\n"
                    "actor \"[Rola Docelowa]\" as target_user\n\n"

                    "' Główny przepływ procesu\n"
                    "user -> web : 1. Inicjuje [nazwa operacji]\n"
                    "activate web\n"
                    "web -> controller : 2. Przekazuje żądanie\n"
                    "activate controller\n\n"

                    "controller -> service : 3. Wywołuje logikę biznesową\n"
                    "activate service\n\n"

                    "' Walidacja/sprawdzenia\n"
                    "service -> repo : 4. Sprawdza warunki\n"
                    "activate repo\n"
                    "repo -> db : SQL: SELECT ...\n"
                    "db --> repo : dane\n"
                    "repo --> service : wynik sprawdzenia\n"
                    "deactivate repo\n\n"

                    "' Warunki biznesowe\n"
                    "alt [warunek spełniony]\n"
                    "    service -> external : 5a. Wywołuje system zewnętrzny\n"
                    "    external --> service : potwierdzenie\n"
                    "    \n"
                    "    service -> repo : 6a. Zapisuje rezultat\n"
                    "    activate repo\n"
                    "    repo -> db : SQL: INSERT/UPDATE ...\n"
                    "    db --> repo : potwierdzenie\n"
                    "    repo --> service : sukces\n"
                    "    deactivate repo\n"
                    "else [warunek niespełniony]\n"
                    "    service -> service : 5b. Logika alternatywna\n"
                    "    note right : Obsługa przypadku wyjątkowego\n"
                    "end\n\n"

                    "service --> controller : rezultat operacji\n"
                    "deactivate service\n"
                    "controller --> web : odpowiedź\n"
                    "deactivate controller\n"
                    "web --> user : 7. Potwierdzenie/komunikat\n"
                    "deactivate web\n\n"

                    "' Powiadomienia (asynchroniczne)\n"
                    "opt [jeśli wymagane powiadomienie]\n"
                    "    service ->> target_user : 8. Powiadomienie o [zdarzeniu]\n"
                    "    note right : Asynchroniczne powiadomienie\n"
                    "end\n\n"

                    "@enduml\n"
                    "```\n\n"

                    "**ZASADY NUMEROWANIA I OPISÓW:**\n"
                    "- Numeruj kolejne interakcje dla lepszej czytelności (1., 2., 3...)\n"
                    "- Opisy komunikatów powinny odzwierciedlać język biznesowy z procesu\n"
                    "- Używaj aktywnych czasowników (\"tworzy\", \"sprawdza\", \"potwierdza\")\n"
                    "- Grupuj logicznie powiązane operacje\n"
                    "- Dodawaj notatki dla skomplikowanych logik\n\n"

                    "**ZASADY NAZEWNICTWA:**\n"
                    "- Nazwy uczestników powinny odzwierciedlać role z procesu biznesowego\n"
                    "- Używaj nazw funkcjonalnych opisujących cel, nie implementację\n"
                    "- Aliasy krótkie, bez spacji (user, payment_service, order_db)\n"
                    "- Konsekwentny język (polski lub angielski)\n"
                    "- Nazwy komunikatów opisują czynność biznesową\n\n"

                    "**KOŃCOWY REZULTAT:**\n"
                    "Dostarcz kompletny, działający kod PlantUML który:\n"
                    "1. Pokazuje chronologiczny przebieg procesu biznesowego\n"
                    "2. Uwzględnia wszystkie scenariusze (główny, alternatywne, błędy)\n"
                    "3. Zawiera odpowiednie typy komunikacji (sync/async)\n"
                    "4. Pokazuje aktywację/dezaktywację uczestników\n"
                    "5. Jest gotowy do użycia bez modyfikacji\n"
                    "6. Zawiera komentarze wyjaśniające mapowanie proces→sekwencja\n"
                    "7. Odzwierciedla rzeczywisty timing i przepływ procesu biznesowego"
                ),
                "allowed_diagram_types": ["sequence"],
                "type": "PlantUML"
            },
            "Diagram aktywności": {
                "template": (
                    "Jako specjalista od kodu PlantUML na podstawie opisu procesu biznesowego: {process_description}\n\n"

                    "**KROK 1: ANALIZA PROCESU BIZNESOWEGO**\n"
                    "Przeanalizuj opisany proces i zidentyfikuj:\n"
                    "- Jaki jest cel procesu i punkt startowy?\n"
                    "- Jakie są główne aktywności/czynności w procesie?\n"
                    "- Gdzie występują decyzje i punkty rozgałęzienia?\n"
                    "- Jakie są warunki i kryteria decyzyjne?\n"
                    "- Które aktywności mogą być wykonywane równolegle?\n"
                    "- Kto jest odpowiedzialny za poszczególne aktywności?\n"
                    "- Gdzie proces może się zakończyć?\n"
                    "- Jakie są wyjątki i ścieżki błędów?\n"
                    "- Czy są pętle/powtarzające się czynności?\n\n"

                    "**KROK 2: IDENTYFIKACJA STRUKTURY PRZEPŁYWU**\n"
                    "Na podstawie analizy określ elementy przepływu:\n\n"

                    "**A) PUNKTY STARTOWE I KOŃCOWE:**\n"
                    "- Co inicjuje proces?\n"
                    "- Jakie są możliwe zakończenia procesu?\n"
                    "- Czy są różne punkty wejścia?\n"
                    "- Czy są punkty przerwania procesu?\n\n"

                    "**B) AKTYWNOŚCI GŁÓWNE:**\n"
                    "- Jakie są kluczowe czynności biznesowe?\n"
                    "- Które aktywności wymagają ludzkiej interwencji?\n"
                    "- Które aktywności są automatyczne?\n"
                    "- Jakie są aktywności przygotowawcze/końcowe?\n\n"

                    "**C) DECYZJE I ROZGAŁĘZIENIA:**\n"
                    "- Gdzie podejmowane są decyzje?\n"
                    "- Jakie są opcje wyboru?\n"
                    "- Jakie są kryteria decyzyjne?\n"
                    "- Czy są decyzje zagnieżdżone?\n\n"

                    "**D) PRZEPŁYWY RÓWNOLEGŁE:**\n"
                    "- Które aktywności można wykonać jednocześnie?\n"
                    "- Gdzie są punkty synchronizacji?\n"
                    "- Czy są aktywności niezależne?\n"
                    "- Gdzie należy poczekać na zakończenie wszystkich ścieżek?\n\n"

                    "**E) ROLE I ODPOWIEDZIALNOŚCI:**\n"
                    "- Kto wykonuje poszczególne aktywności?\n"
                    "- Czy są różne role w procesie?\n"
                    "- Gdzie następuje przekazanie odpowiedzialności?\n"
                    "- Czy są aktywności międzydziałowe?\n\n"

                    "**KROK 3: MAPOWANIE PRZEPŁYWU LOGICZNEGO**\n"
                    "Dla każdej aktywności i decyzji określ:\n\n"

                    "**A) SEKWENCJA GŁÓWNA:**\n"
                    "- Jaka jest naturalna kolejność aktywności?\n"
                    "- Które aktywności są obligatoryjne?\n"
                    "- Gdzie są punkty kontrolne?\n"
                    "- Jakie są wejścia i wyjścia każdej aktywności?\n\n"

                    "**B) ŚCIEŻKI WARUNKOWE:**\n"
                    "- Jakie warunki determinują wybór ścieżki?\n"
                    "- Czy wszystkie ścieżki prowadzą do tego samego punktu?\n"
                    "- Gdzie są punkty scalania ścieżek?\n"
                    "- Jakie są alternatywne przepływy?\n\n"

                    "**C) OBSŁUGA WYJĄTKÓW:**\n"
                    "- Co dzieje się w przypadku błędów?\n"
                    "- Jakie są mechanizmy recovery?\n"
                    "- Czy są aktywności kompensacyjne?\n"
                    "- Gdzie proces może zostać przerwany?\n\n"

                    "**D) PĘTLE I ITERACJE:**\n"
                    "- Które aktywności się powtarzają?\n"
                    "- Jakie są warunki przerwania pętli?\n"
                    "- Czy są pętle zagnieżdżone?\n"
                    "- Gdzie są punkty powrotu?\n\n"

                    "**KROK 4: GENEROWANIE DIAGRAMU PlantUML**\n"
                    "Wygeneruj kompletny kod PlantUML w podstawowej notacji z następującymi wymaganiami:\n\n"

                    "**STRUKTURA TECHNICZNA:**\n"
                    "1. **Rozpocznij:** `@startuml`\n"
                    "2. **Tytuł:** `title [Nazwa Procesu] - Przepływ Aktywności`\n"
                    "3. **Tema:** `!theme plain` lub pomiń dla domyślnego stylu\n"
                    "4. **WAŻNE - Swimlanes:** Jeśli używasz swimlanes, zdefiniuj je PRZED `start`\n"
                    "5. **Start:** `start` - punkt początkowy\n"
                    "6. **Logiczna sekwencja aktywności**\n"
                    "7. **Zakończ:** `@enduml`\n\n"

                    "**PODSTAWOWE ELEMENTY:**\n"
                    "- `start` - punkt początkowy\n"
                    "- `end` - punkt końcowy\n"
                    "- `stop` - punkt zatrzymania\n"
                    "- `:Nazwa aktywności;` - aktywność\n"
                    "- `if (warunek?) then (tak)` - decyzja z warunkiem\n"
                    "- `elseif (warunek2) then` - dodatkowy warunek\n"
                    "- `else (nie)` - alternatywa\n"
                    "- `endif` - koniec decyzji\n"
                    "- `while (warunek?)` - pętla\n"
                    "- `endwhile` - koniec pętli\n"
                    "- `repeat` - pętla repeat-until\n"
                    "- `repeat while (warunek?)` - koniec pętli repeat\n\n"

                    "**PRZEPŁYWY RÓWNOLEGŁE:**\n"
                    "- `fork` - rozpoczęcie przepływów równoległych\n"
                    "- `fork again` - kolejny przepływ równoległy\n"
                    "- `end fork` - koniec przepływów równoległych\n"
                    "- `split` - alternatywne rozgałęzienie\n"
                    "- `split again` - kolejne rozgałęzienie\n"
                    "- `end split` - koniec rozgałęzień\n\n"

                    "**ROLE I GRUPY:**\n"
                    "- `|Nazwa Roli|` - swimlane dla roli\n"
                    "- `partition \"Nazwa Grupy\" {{ }}` - grupowanie aktywności\n"
                    "- `group \"Nazwa Grupy\"` / `end group` - logiczne grupowanie\n\n"

                    "**DODATKOWE ELEMENTY:**\n"
                    "- `note left/right : tekst` - notatki\n"
                    "- `floating note : tekst` - notatka pływająca\n"
                    "- `kill` - natychmiastowe zakończenie\n"
                    "- `detach` - odłączenie od głównego przepływu\n"
                    "- `backward :Aktywność;` - aktywność wsteczna\n\n"

                    "**KOLORY I STYLE:**\n"
                    "- `#LightBlue` - kolor aktywności\n"
                    "- `#Pink` - kolor decyzji\n"
                    "- `#LightGreen` - kolor sukcesu\n"
                    "- `#Orange` - kolor ostrzeżenia\n"
                    "- `#Red` - kolor błędu\n\n"

                    "**PRZYKŁAD STRUKTURY:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "title [Nazwa Procesu] - Przepływ Aktywności\n\n"

                    "' WAŻNE: Swimlanes muszą być zdefiniowane PRZED start\n"
                    "|Inicjator|\n"
                    "|Procesor|\n"
                    "|Zarządzający|\n\n"

                    "start\n\n"

                    "' Aktywności w swimlanes\n"
                    "|Inicjator|\n"
                    ":Rozpoczęcie procesu;\n"
                    ":Przygotowanie danych;\n\n"

                    "' Decyzja z warunkiem\n"
                    "if (Dane kompletne?) then (tak)\n"
                    "  |Procesor|\n"
                    "  :Walidacja danych;\n"
                    "  \n"
                    "  if (Walidacja OK?) then (tak)\n"
                    "    ' Przepływ równoległy\n"
                    "    fork\n"
                    "      :Przetwarzanie główne;\n"
                    "    fork again\n"
                    "      :Generowanie raportu;\n"
                    "    fork again\n"
                    "      :Wysyłanie powiadomień;\n"
                    "    end fork\n"
                    "    \n"
                    "    :Finalizacja procesu;\n"
                    "    \n"
                    "  else (nie)\n"
                    "    :Obsługa błędów walidacji;\n"
                    "    |Inicjator|\n"
                    "    :Korekta danych;\n"
                    "    \n"
                    "    ' Pętla dla poprawek\n"
                    "    while (Więcej poprawek?) is (tak)\n"
                    "      :Wprowadzanie poprawek;\n"
                    "    endwhile (nie)\n"
                    "  endif\n"
                    "  \n"
                    "else (nie)\n"
                    "  :Pozyskanie brakujących danych;\n"
                    "  note right : Może wymagać kontaktu\\nz zewnętrznymi źródłami\n"
                    "endif\n\n"

                    "' Zakończenie procesu\n"
                    "|Zarządzający|\n"
                    ":Przegląd wyników;\n\n"

                    "if (Wyniki akceptowalne?) then (tak)\n"
                    "  :Zatwierdzenie procesu;\n"
                    "  #LightGreen:Proces zakończony sukcesem;\n"
                    "  end\n"
                    "else (nie)\n"
                    "  #Orange:Proces wymaga ponowienia;\n"
                    "  stop\n"
                    "endif\n\n"

                    "@enduml\n"
                    "```\n\n"

                    "**ZASADY NAZEWNICTWA I OPISÓW:**\n"
                    "- Nazwy aktywności powinny być czasownikami opisującymi akcję\n"
                    "- Używaj języka biznesowego, nie technicznego\n"
                    "- Warunki formułuj jako pytania (\"Dane poprawne?\")\n"
                    "- Odpowiedzi na warunki powinny być jednoznaczne (tak/nie)\n"
                    "- Grupuj logicznie powiązane aktywności\n"
                    "- Używaj kolorów do wyróżnienia typów aktywności\n\n"

                    "**ZASADY STRUKTURY:**\n"
                    "- Jeden główny przepływ z odgałęzieniami\n"
                    "- Jasne punkty decyzyjne z wszystkimi ścieżkami\n"
                    "- Minimalizuj skrzyżowania linii\n"
                    "- Grupuj aktywności według odpowiedzialności\n"
                    "- Pokazuj wszystkie możliwe zakończenia procesu\n"
                    "- Używaj notatek dla skomplikowanych warunków\n\n"

                    "**KOŃCOWY REZULTAT:**\n"
                    "Dostarcz kompletny, działający kod PlantUML który:\n"
                    "1. Pokazuje kompletny przepływ procesu biznesowego\n"
                    "2. Uwzględnia wszystkie decyzje i alternatywne ścieżki\n"
                    "3. Zawiera odpowiednie role i odpowiedzialności\n"
                    "4. Pokazuje przepływy równoległe gdzie są potrzebne\n"
                    "5. Obsługuje wyjątki i ścieżki błędów\n"
                    "6. Jest gotowy do użycia bez modyfikacji\n"
                    "7. Zawiera komentarze wyjaśniające logikę procesu\n"
                    "8. Odzwierciedla rzeczywistą kolejność i logikę biznesową\n"
                    "9. Używa odpowiednich kolorów dla lepszej czytelności"
                ),
                "allowed_diagram_types": ["activity"],
                "type": "PlantUML"
            },
            "Diagram przypadków użycia": {
                "template": (
                    "Na podstawie opisu procesu biznesowego: {process_description}\n\n"

                    "**KROK 1: ANALIZA FUNKCJI BIZNESOWYCH PROCESU**\n"
                    "Przeanalizuj opisany proces i zidentyfikuj:\n"
                    "- Kto są użytkownicy procesu (role, aktorzy)?\n"
                    "- Jakie cele biznesowe chcą osiągnąć?\n"
                    "- Jakie główne funkcje/działania wykonują w procesie?\n"
                    "- Jakie są rezultaty/wartości dostarczane przez proces?\n"
                    "- Z jakimi systemami zewnętrznymi proces się integruje?\n"
                    "- Jakie są warunki wstępne i końcowe dla każdej funkcji?\n"
                    "- Gdzie występują warianty/alternatywy w procesie?\n"
                    "- Jakie są wyjątki i sytuacje błędne?\n\n"

                    "**KROK 2: IDENTYFIKACJA AKTORÓW I PRZYPADKÓW UŻYCIA**\n"
                    "Na podstawie analizy określ elementy diagramu:\n\n"

                    "**A) AKTORZY GŁÓWNI (PRIMARY ACTORS):**\n"
                    "- Kto inicjuje proces i czerpie z niego korzyści?\n"
                    "- Jakie role biznesowe bezpośrednio uczestniczą?\n"
                    "- Czy są różne typy użytkowników z różnymi uprawnieniami?\n"
                    "- Czy są aktorzy reprezentujący organizacje/działy?\n\n"

                    "**B) AKTORZY POMOCNICZY (SECONDARY ACTORS):**\n"
                    "- Jakie systemy zewnętrzne wspierają proces?\n"
                    "- Jakie serwisy/API są wywoływane?\n"
                    "- Czy są automatyczne procesy/timery?\n"
                    "- Jakie systemy dostarczają dane referencyjne?\n\n"

                    "**C) PRZYPADKI UŻYCIA GŁÓWNE:**\n"
                    "- Jakie są kluczowe funkcje biznesowe procesu?\n"
                    "- Jakie zadania wykonują poszczególni aktorzy?\n"
                    "- Jakie są kompletne scenariusze end-to-end?\n"
                    "- Które funkcje dostarczają bezpośrednią wartość biznesową?\n\n"

                    "**D) PRZYPADKI UŻYCIA WSPIERAJĄCE:**\n"
                    "- Jakie są funkcje pomocnicze/administracyjne?\n"
                    "- Jakie są funkcje zarządzania danymi?\n"
                    "- Jakie są funkcje raportowania/monitorowania?\n"
                    "- Jakie są funkcje konfiguracji/ustawień?\n\n"

                    "**KROK 3: MAPOWANIE RELACJI I ZALEŻNOŚCI**\n"
                    "Określ związki między elementami:\n\n"

                    "**A) RELACJE MIĘDZY AKTORAMI:**\n"
                    "- Czy istnieją hierarchie ról (generalizacja)?\n"
                    "- Czy są grupy aktorów o podobnych funkcjach?\n"
                    "- Czy są aktorzy abstrakcyjni/konkretni?\n\n"

                    "**B) RELACJE MIĘDZY PRZYPADKAMI UŻYCIA:**\n"
                    "- Które przypadki użycia zawierają wspólne elementy (include)?\n"
                    "- Które są opcjonalnymi rozszerzeniami innych (extend)?\n"
                    "- Czy są przypadki użycia abstrakcyjne/konkretne?\n"
                    "- Gdzie występują specjalizacje funkcji?\n\n"

                    "**C) GRANICE SYSTEMU:**\n"
                    "- Co jest wewnątrz systemu a co zewnątrz?\n"
                    "- Jakie są granice odpowiedzialności?\n"
                    "- Które funkcje są automatyczne a które manualne?\n\n"

                    "**KROK 4: GENEROWANIE DIAGRAMU PlantUML**\n"
                    "Wygeneruj kompletny kod PlantUML w notacji przypadków użycia z następującymi wymaganiami:\n\n"

                    "**STRUKTURA TECHNICZNA:**\n"
                    "1. **Rozpocznij:** `@startuml`\n"
                    "2. **Tytuł:** `title [Nazwa Procesu] - Przypadki Użycia`\n"
                    "3. **Definicje aktorów przed przypadkami użycia**\n"
                    "4. **Grupowanie w granicach systemu**\n"
                    "5. **Zakończ:** `@enduml`\n\n"

                    "**AKTORZY DO UŻYCIA:**\n"
                    "- `actor \"Nazwa\" as alias` - użytkownicy/role biznesowe\n"
                    "- `:Nazwa:` - alternatywna notacja aktora\n"
                    "- `actor \"Nazwa\" <<system>> as alias` - systemy zewnętrzne\n"
                    "- `actor \"Nazwa\" <<device>> as alias` - urządzenia\n"
                    "- `actor \"Nazwa\" <<timer>> as alias` - procesy czasowe\n\n"

                    "**PRZYPADKI UŻYCIA:**\n"
                    "- `usecase \"Nazwa\" as alias` - podstawowe przypadki użycia\n"
                    "- `(Nazwa)` - alternatywna notacja\n"
                    "- `usecase \"Nazwa\" <<system>> as alias` - funkcje systemowe\n"
                    "- `usecase \"Nazwa\" <<report>> as alias` - funkcje raportowe\n\n"

                    "**GRANICE I GRUPOWANIE:**\n"
                    "- `rectangle \"Nazwa Systemu\" {{ }}` - granice głównego systemu\n"
                    "- `package \"Moduł\" {{ }}` - grupowanie funkcjonalne\n"
                    "- `node \"Podsystem\" {{ }}` - podsystemy\n"
                    "- `frame \"Obszar\" {{ }}` - obszary biznesowe\n\n"

                    "**RELACJE I ZWIĄZKI:**\n"
                    "- `-->` - asocjacja aktora z przypadkiem użycia\n"
                    "- `..>` - relacja include/extend z etykietą\n"
                    "- `--|>` - generalizacja (dziedziczenie)\n"
                    "- `<<include>>` - obowiązkowe włączenie\n"
                    "- `<<extend>>` - opcjonalne rozszerzenie\n\n"

                    "**STEREOTYPY I ETYKIETY:**\n"
                    "- `<<include>>` - wspólne funkcje\n"
                    "- `<<extend>>` - opcjonalne rozszerzenia\n"
                    "- `<<system>>` - funkcje automatyczne\n"
                    "- `<<manual>>` - funkcje manualne\n"
                    "- `<<critical>>` - funkcje krytyczne\n\n"

                    "**PRZYKŁAD STRUKTURY:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "title [Nazwa Procesu] - Przypadki Użycia\n\n"

                    "' Aktorzy główni z procesu biznesowego\n"
                    "actor \"[Rola Główna]\" as main_user\n"
                    "actor \"[Rola Zatwierdzająca]\" as approver\n"
                    "actor \"Administrator\" as admin\n\n"

                    "' Aktorzy pomocniczy (systemy zewnętrzne)\n"
                    "actor \"[System Zewnętrzny]\" <<system>> as external_system\n"
                    "actor \"[System Powiadomień]\" <<system>> as notification_system\n\n"

                    "' Granice systemu\n"
                    "rectangle \"System [Nazwa Procesu]\" {{\n\n"

                    "    ' Główne przypadki użycia z procesu\n"
                    "    package \"Funkcje Główne\" {{\n"
                    "        usecase \"[Główna Funkcja 1]\" as main_uc1\n"
                    "        usecase \"[Główna Funkcja 2]\" as main_uc2\n"
                    "        usecase \"[Zatwierdzenie Procesu]\" as approve_uc\n"
                    "    }}\n\n"

                    "    ' Funkcje wspierające\n"
                    "    package \"Funkcje Wspierające\" {{\n"
                    "        usecase \"Walidacja Danych\" as validate_uc\n"
                    "        usecase \"Generowanie Raportu\" as report_uc\n"
                    "        usecase \"Wysłanie Powiadomienia\" as notify_uc\n"
                    "    }}\n\n"

                    "    ' Funkcje administracyjne\n"
                    "    package \"Administracja\" {{\n"
                    "        usecase \"Zarządzanie Konfiguracją\" as config_uc\n"
                    "        usecase \"Monitorowanie Procesów\" as monitor_uc\n"
                    "    }}\n"
                    "}}\n\n"

                    "' Relacje aktor-przypadek użycia\n"
                    "main_user --> main_uc1 : \"Inicjuje\"\n"
                    "main_user --> main_uc2 : \"Wykonuje\"\n"
                    "approver --> approve_uc : \"Zatwierdza\"\n"
                    "admin --> config_uc : \"Konfiguruje\"\n"
                    "admin --> monitor_uc : \"Monitoruje\"\n\n"

                    "' Relacje include/extend\n"
                    "main_uc1 ..> validate_uc : <<include>>\n"
                    "main_uc2 ..> validate_uc : <<include>>\n"
                    "approve_uc ..> notify_uc : <<include>>\n"
                    "main_uc1 ..> report_uc : <<extend>>\n\n"

                    "' Integracje z systemami zewnętrznymi\n"
                    "validate_uc --> external_system : \"Weryfikuje\"\n"
                    "notify_uc --> notification_system : \"Wysyła\"\n\n"

                    "' Generalizacje (jeśli występują)\n"
                    "main_user --|> approver : \"może być również\"\n\n"

                    "' Notatki wyjaśniające\n"
                    "note right of main_uc1 : \"Główny przepływ procesu biznesowego\"\n"
                    "note left of validate_uc : \"Wspólna walidacja dla wszystkich funkcji\"\n\n"

                    "@enduml\n"
                    "```\n\n"

                    "**ZASADY NAZEWNICTWA:**\n"
                    "- Nazwy przypadków użycia jako frazy czasownikowe (\"Złóż Wniosek\", \"Zatwierdź Dokument\")\n"
                    "- Nazwy aktorów jako role/funkcje biznesowe (\"Wnioskodawca\", \"Kierownik\")\n"
                    "- Aliasy krótkie, bez spacji (submit_request, approve_doc)\n"
                    "- Konsekwentny język (polski lub angielski)\n"
                    "- Nazwy odzwierciedlające wartość biznesową, nie implementację techniczną\n\n"

                    "**ZASADY MODELOWANIA FUNKCJONALNEGO:**\n"
                    "- Każdy przypadek użycia reprezentuje kompletną funkcję biznesową\n"
                    "- Aktorzy reprezentują role, nie konkretne osoby\n"
                    "- Granice systemu pokazują zakres odpowiedzialności\n"
                    "- Include dla obowiązkowych funkcji wspólnych\n"
                    "- Extend dla opcjonalnych rozszerzeń\n"
                    "- Generalizacja dla hierarchii ról/funkcji\n\n"

                    "**KOŃCOWY REZULTAT:**\n"
                    "Dostarcz kompletny, działający kod PlantUML który:\n"
                    "1. Odzwierciedla wszystkie funkcje biznesowe wynikające z procesu\n"
                    "2. Pokazuje role i ich interakcje z systemem\n"
                    "3. Zawiera hierarchie i zależności między funkcjami\n"
                    "4. Określa granice systemu i integracje zewnętrzne\n"
                    "5. Jest gotowy do użycia bez modyfikacji\n"
                    "6. Zawiera komentarze wyjaśniające mapowanie proces→funkcje\n"
                    "7. Prezentuje perspektywę użytkownika końcowego na system"
                ),
                "allowed_diagram_types": ["usecase"],
                "type": "PlantUML"
            },
            "Diagram klas": {
                "template": (
                    "Jako specjalista od kodu PlantUML na podstawie opisu procesu biznesowego: {process_description}\n\n"
                    
                    "**KROK 1: ANALIZA PROCESU BIZNESOWEGO**\n"
                    "Przeanalizuj opisany proces i zidentyfikuj:\n"
                    "- Jakie **RZECZOWNIKI** (obiekty/encje) występują w procesie?\n"
                    "- Jakie **CZASOWNIKI** (akcje/operacje) są wykonywane?\n"
                    "- Jakie **PRZYMIOTNIKI** (właściwości/atrybuty) opisują obiekty?\n"
                    "- Jakie **REGUŁY BIZNESOWE** rządzą procesem?\n"
                    "- Jakie **STANY** mogą mieć obiekty w procesie?\n"
                    "- Jakie **RELACJE** istnieją między obiektami?\n"
                    "- Zidentyfikuj nazwę procesu i użyj jej przy generowaniu diagramu\n\n"
                    
                    "**KROK 2: IDENTYFIKACJA KLAS I OBIEKTÓW**\n"
                    "Na podstawie analizy określ jakie klasy są potrzebne:\n\n"
                    
                    "**A) KLASY GŁÓWNE (ENTITY CLASSES):**\n"
                    "- Jakie są główne obiekty biznesowe w procesie?\n"
                    "- Które rzeczowniki reprezentują trwałe dane?\n"
                    "- Które obiekty mają unikalną tożsamość?\n"
                    "- Które obiekty są przechowywane w bazie danych?\n"
                    "Przykład: Zamówienie, Klient, Produkt, Faktura\n\n"
                    
                    "**B) KLASY WARTOŚCI (VALUE OBJECTS):**\n"
                    "- Które obiekty reprezentują wartości bez tożsamości?\n"
                    "- Które dane są niezmienne (immutable)?\n"
                    "- Które obiekty są definiowane przez swoje atrybuty?\n"
                    "Przykład: Adres, Cena, DataCzas, StatusZamówienia\n\n"
                    
                    "**C) KLASY KONTROLNE (CONTROL CLASSES):**\n"
                    "- Które akcje/operacje wymagają dedykowanych klas?\n"
                    "- Które procesy są złożone i wymagają orkiestracji?\n"
                    "- Które reguły biznesowe są skomplikowane?\n"
                    "Przykład: MenedżerZamówień, KalkulatorCen, ValidatorDanych\n\n"
                    
                    "**D) KLASY POMOCNICZE (UTILITY CLASSES):**\n"
                    "- Które operacje są wspólne dla wielu klas?\n"
                    "- Które funkcje nie należą do konkretnego obiektu?\n"
                    "- Które narzędzia są potrzebne do wspomagania procesu?\n"
                    "Przykład: DateUtils, StringHelper, Logger\n\n"
                    
                    "**E) ENUMERACJE I INTERFEJSY:**\n"
                    "- Które wartości mają ograniczoną listę opcji?\n"
                    "- Które zachowania mogą być implementowane różnie?\n"
                    "- Które kontrakty muszą być zdefiniowane?\n"
                    "Przykład: enum StatusZamówienia, interface IPłatność\n\n"
                    
                    "**KROK 3: ANALIZA ATRYBUTÓW I METOD**\n"
                    "Dla każdej zidentyfikowanej klasy określ:\n\n"
                    
                    "**ATRYBUTY:**\n"
                    "- Jakie **dane** przechowuje klasa?\n"
                    "- Które atrybuty są **publiczne** (+), **prywatne** (-), **chronione** (#)?\n"
                    "- Jakie są **typy** danych (string, int, decimal, DateTime, etc.)?\n"
                    "- Które atrybuty są **kluczami** (ID, unique identifiers)?\n"
                    "- Które atrybuty mają **wartości domyślne**?\n\n"
                    
                    "**METODY:**\n"
                    "- Jakie **operacje** może wykonywać klasa?\n"
                    "- Które metody są **publiczne** (+), **prywatne** (-), **chronione** (#)?\n"
                    "- Jakie są **parametry** i **typy zwracane**?\n"
                    "- Które metody są **konstruktorami**?\n"
                    "- Które metody implementują **reguły biznesowe**?\n\n"
                    
                    "**KROK 4: ANALIZA RELACJI**\n"
                    "Określ relacje między klasami:\n\n"
                    
                    "**ASOCJACJE:**\n"
                    "- Które klasy **współpracują** ze sobą?\n"
                    "- Jaka jest **kardinalność** relacji (1..1, 1..*, *..*)?\n"
                    "- Czy relacja jest **dwukierunkowa** czy **jednokierunkowa**?\n"
                    "- Jakie są **role** w relacji?\n\n"
                    
                    "**DZIEDZICZENIE (BARDZO WAŻNE!):**\n"
                    "- Które klasy są **specjalizacjami** (dziećmi) innych, bardziej ogólnych klas (rodziców)?\n"
                    "- **Kluczowa reguła:** Relacja dziedziczenia (`--|>`) MUSI zawsze prowadzić od dziecka do rodzica. Przykład: `class Przelew extends TypTransakcji` w kodzie oznacza `Przelew --|> TypTransakcji` w PlantUML. Nigdy na odwrót! Dokładnie zweryfikuj ten kierunek.\n"
                    "- Czy potrzebne są klasy abstrakcyjne do zebrania wspólnych cech?\n\n"
                    
                    "**AGREGACJA/KOMPOZYCJA:**\n"
                    "- Które klasy są **częściami** innych klas?\n"
                    "- Czy części mogą istnieć **niezależnie** (agregacja) czy **nie** (kompozycja)?\n\n"
                    
                    "**IMPLEMENTACJA:**\n"
                    "- Które klasy **implementują** interfejsy?\n"
                    "- Które klasy **używają** innych klas?\n\n"
                    
                    "**KROK 5: GENEROWANIE DIAGRAMU PlantUML**\n"
                    "Wygeneruj kompletny kod PlantUML z następującymi wymaganiami:\n\n"
                    
                    "**STRUKTURA TECHNICZNA:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "title [Nazwa Procesu] - Model Klas\n\n"
                    
                    "' Klasy główne\n"
                    "class ClassName {{\n"
                    "    +publicAttribute: Type\n"
                    "    -privateAttribute: Type\n"
                    "    #protectedAttribute: Type\n"
                    "    --\n"
                    "    +ClassName(param: Type)\n"
                    "    +publicMethod(): ReturnType\n"
                    "    -privateMethod(param: Type): ReturnType\n"
                    "    +{{static}} staticMethod(): Type\n"
                    "    +{{abstract}} abstractMethod(): Type\n"
                    "}}\n\n"
                    
                    "abstract class AbstractClass {{\n"
                    "    #{{abstract}} abstractMethod(): Type\n"
                    "}}\n\n"
                    
                    "interface IInterface {{\n"
                    "    +interfaceMethod(): Type\n"
                    "}}\n\n"
                    
                    "enum StatusEnum {{\n"
                    "    VALUE1\n"
                    "    VALUE2\n"
                    "    VALUE3\n"
                    "}}\n\n"
                    
                    "' Relacje\n"
                    "Class1 ||--o{{ Class2 : \"zawiera\"\n"
                    "Class1 --> Class3 : \"używa\"\n"
                    "Class4 --|> AbstractClass : \"dziedziczy\"\n"
                    "Class5 ..|> IInterface : \"implementuje\"\n"
                    "Class6 ..> Class7 : \"zależy od\"\n"
                    "@enduml\n"
                    "```\n\n"
                    
                    "**TYPY RELACJI PlantUML:**\n"
                    "- `-->` : Asocjacja/używa\n"
                    "- `--` : Asocjacja dwukierunkowa\n"
                    "- `--|>` : Dziedziczenie (extends) (Pamiętaj: Zawsze od DZIECKA do RODZICA!)\n"
                    "- `..|>` : Implementacja (implements)\n"
                    "- `||--` : Kompozycja (część-całość, silna)\n"
                    "- `o--` : Agregacja (część-całość, słaba)\n"
                    "- `..>` : Zależność (dependency)\n"
                    "- `*--` : Kompozycja z kardynalnością\n\n"
                    
                    "**KARDINALNOŚĆ:**\n"
                    "- `\"1\"` : dokładnie jeden\n"
                    "- `\"0..1\"` : zero lub jeden\n"
                    "- `\"1..*\"` : jeden lub więcej\n"
                    "- `\"*\"` : zero lub więcej\n"
                    "- `\"n\"` : dokładnie n\n\n"
                    
                    "**MODYFIKATORY DOSTĘPU:**\n"
                    "- `+` : public\n"
                    "- `-` : private\n"
                    "- `#` : protected\n"
                    "- `~` : package\n\n"
                    
                    "**MODYFIKATORY METOD:**\n"
                    "- `{{static}}` : metoda statyczna\n"
                    "- `{{abstract}}` : metoda abstrakcyjna\n"
                    "- `{{final}}` : metoda finalna\n\n"
                    
                    "**GRUPOWANIE I ORGANIZACJA:**\n"
                    "```plantuml\n"
                    "package \"Domain Model\" {{\n"
                    "    class DomainClass1\n"
                    "    class DomainClass2\n"
                    "}}\n\n"
                    
                    "package \"Services\" {{\n"
                    "    class ServiceClass1\n"
                    "    class ServiceClass2\n"
                    "}}\n\n"
                    
                    "package \"Value Objects\" {{\n"
                    "    class ValueObject1\n"
                    "    enum StatusEnum\n"
                    "}}\n"
                    "```\n\n"
                    
                    "**ZASADY NAZEWNICTWA:**\n"
                    "- Nazwy klas: **PascalCase** (OrderService, CustomerData)\n"
                    "- Nazwy atrybutów: **camelCase** (firstName, orderDate)\n"
                    "- Nazwy metod: **camelCase** (calculateTotal, validateData)\n"
                    "- Nazwy konstant: **UPPER_CASE** (MAX_ITEMS, DEFAULT_STATUS)\n"
                    "- Interfejsy: prefix **I** (IPaymentProcessor, IOrderValidator)\n"
                    "- Klasy abstrakcyjne: prefix **Abstract** (AbstractProcessor)\n\n"
                    
                    "**DOBRE PRAKTYKI:**\n"
                    "- Oddzielaj atrybuty od metod linią `--`\n"
                    "- Grupuj powiązane klasy w packages\n"
                    "- Używaj komentarzy (') do opisania złożonych relacji\n"
                    "- Określaj kardinalność dla wszystkich asocjacji\n"
                    "- Dodawaj etykiety do relacji opisujące ich znaczenie\n"
                    "- Umieszczaj enumeracje blisko klas, które ich używają\n\n"
                    
                    "**KOŃCOWY REZULTAT:**\n"
                    "Dostarcz kompletny, działający kod PlantUML który:\n"
                    "1. Modeluje wszystkie istotne obiekty z procesu biznesowego\n"
                    "2. Zawiera poprawne atrybuty i metody wyprowadzone z analizy\n"
                    "3. Pokazuje wszystkie istotne relacje między klasami\n"
                    "4. Jest podzielony na logiczne pakiety/moduły\n"
                    "5. Zawiera komentarze wyjaśniające mapowanie proces→klasy\n"
                    "6. Jest gotowy do użycia jako podstawa do implementacji\n"
                    "7. Odzwierciedla rzeczywiste reguły biznesowe w strukturze kodu"
                ),
                "allowed_diagram_types": ["class"],
                "type": "PlantUML"
            },
            "Diagram przepływów": {
                "template": (
                    "Na podstawie opisu procesu biznesowego: {process_description}\n\n"

                    "**KROK 1: ANALIZA PROCESU BIZNESOWEGO**\n"
                    "Przeanalizuj opisany proces i zidentyfikuj:\n"
                    "- Jaki jest punkt startowy procesu?\n"
                    "- Jakie są główne etapy/kroki procesu?\n"
                    "- Gdzie występują punkty decyzyjne?\n"
                    "- Jakie są warunki i kryteria dla każdej decyzji?\n"
                    "- Które operacje są procesami (przetwarzanie)?\n"
                    "- Które operacje są operacjami I/O (wejście/wyjście)?\n"
                    "- Jakie są możliwe zakończenia procesu?\n"
                    "- Gdzie mogą wystąpić błędy lub wyjątki?\n"
                    "- Czy są pętle lub iteracje w procesie?\n"
                    "- Jakie dane przepływają między krokami?\n\n"

                    "**KROK 2: KLASYFIKACJA ELEMENTÓW PRZEPŁYWU**\n"
                    "Na podstawie analizy skategoryzuj elementy:\n\n"

                    "**A) PUNKTY KONTROLNE:**\n"
                    "- Gdzie proces się rozpoczyna?\n"
                    "- Gdzie proces się kończy (sukces/błąd)?\n"
                    "- Czy są punkty przerwania procesu?\n"
                    "- Gdzie są punkty kontroli jakości?\n\n"

                    "**B) OPERACJE PRZETWARZANIA:**\n"
                    "- Jakie są główne operacje biznesowe?\n"
                    "- Które operacje transformują dane?\n"
                    "- Które operacje wykonują obliczenia?\n"
                    "- Które operacje są automatyczne vs manualne?\n\n"

                    "**C) OPERACJE WEJŚCIA/WYJŚCIA:**\n"
                    "- Gdzie dane są wprowadzane do systemu?\n"
                    "- Gdzie dane są pobierane z zewnątrz?\n"
                    "- Gdzie wyniki są prezentowane użytkownikowi?\n"
                    "- Gdzie dane są zapisywane/archiwizowane?\n\n"

                    "**D) PUNKTY DECYZYJNE:**\n"
                    "- Jakie są kryteria decyzyjne?\n"
                    "- Ile opcji ma każda decyzja?\n"
                    "- Czy decyzje są binarne (tak/nie) czy wielowariantowe?\n"
                    "- Czy są decyzje zagnieżdżone?\n\n"

                    "**E) PRZEPŁYWY DANYCH:**\n"
                    "- Jakie informacje przepływają między krokami?\n"
                    "- Gdzie dane są modyfikowane?\n"
                    "- Które dane są wymagane dla każdego kroku?\n"
                    "- Gdzie są punkty walidacji danych?\n\n"

                    "**KROK 3: MAPOWANIE LOGIKI PROCESU**\n"
                    "Dla każdego elementu określ:\n\n"

                    "**A) SEKWENCJA GŁÓWNA:**\n"
                    "- Jaka jest standardowa ścieżka procesu?\n"
                    "- Które kroki są obligatoryjne?\n"
                    "- Gdzie są punkty bez powrotu?\n"
                    "- Jakie są zależności między krokami?\n\n"

                    "**B) ŚCIEŻKI ALTERNATYWNE:**\n"
                    "- Jakie są alternatywne przepływy?\n"
                    "- Które ścieżki prowadzą do tego samego punktu?\n"
                    "- Gdzie są punkty scalania ścieżek?\n"
                    "- Jakie są skróty w procesie?\n\n"

                    "**C) OBSŁUGA BŁĘDÓW:**\n"
                    "- Gdzie mogą wystąpić błędy?\n"
                    "- Jak są obsługiwane różne typy błędów?\n"
                    "- Czy są mechanizmy recovery?\n"
                    "- Gdzie proces kończy się niepowodzeniem?\n\n"

                    "**D) PĘTLE I POWTÓRZENIA:**\n"
                    "- Które kroki mogą być powtarzane?\n"
                    "- Jakie są warunki wyjścia z pętli?\n"
                    "- Gdzie są punkty powrotu?\n"
                    "- Czy są ograniczenia liczby iteracji?\n\n"

                    "**KROK 4: GENEROWANIE DIAGRAMU PlantUML**\n"
                    "Wygeneruj kompletny kod PlantUML w podstawowej notacji z następującymi wymaganiami:\n\n"

                    "**STRUKTURA TECHNICZNA:**\n"
                    "1. **Rozpocznij:** `@startuml`\n"
                    "2. **Tytuł:** `title [Nazwa Procesu] - Diagram Przepływu`\n"
                    "3. **Tema:** `!theme plain` lub pomiń dla domyślnego stylu\n"
                    "4. **Definicje wszystkich węzłów przed połączeniami**\n"
                    "5. **Logiczne połączenia między węzłami**\n"
                    "6. **Zakończ:** `@enduml`\n\n"

                    "**TYPY WĘZŁÓW DO UŻYCIA:**\n"
                    "- `(start)` - punkt początkowy (elipsa)\n"
                    "- `(end)` - punkt końcowy (elipsa)\n"
                    "- `[Proces]` - operacja przetwarzania (prostokąt)\n"
                    "- `<Wejście/Wyjście>` - operacja I/O (równoległobok)\n"
                    "- `{{Decyzja?}}` - punkt decyzyjny (romb)\n"
                    "- `((Łącznik))` - punkt połączenia (koło)\n"
                    "- `[[Predefined]]` - predefiniowany proces (prostokąt dwuliniowy)\n"
                    "- `>Dokument]` - dokument (prostokąt z falistym dołem)\n"
                    "- `[(Database)]` - baza danych (cylinder)\n\n"

                    "**POŁĄCZENIA I ETYKIETY:**\n"
                    "- `-->` - standardowe połączenie\n"
                    "- `--> : etykieta` - połączenie z opisem\n"
                    "- `-.->` - połączenie przerywane (alternatywne)\n"
                    "- `==>` - połączenie pogrubione (główny przepływ)\n"
                    "- `-left->`, `-right->`, `-up->`, `-down->` - kierunkowe połączenia\n\n"

                    "**KOLORY I STYLE:**\n"
                    "- `#LightBlue` - procesy standardowe\n"
                    "- `#LightGreen` - procesy sukcesu\n"
                    "- `#Pink` - punkty decyzyjne\n"
                    "- `#Orange` - ostrzeżenia/wyjątki\n"
                    "- `#Red` - błędy/problemy\n"
                    "- `#Yellow` - operacje I/O\n"
                    "- `#LightGray` - operacje pomocnicze\n\n"

                    "**GRUPOWANIE I ORGANIZACJA:**\n"
                    "- `package \"Grupa\" {{ }}` - grupowanie logiczne\n"
                    "- `rectangle \"Obszar\" {{ }}` - obszar odpowiedzialności\n"
                    "- `cloud \"Chmura\" {{ }}` - elementy zewnętrzne\n"
                    "- `frame \"Rama\" {{ }}` - granice systemu\n\n"

                    "**PRZYKŁAD STRUKTURY:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "!theme plain\n"
                    "title [Nazwa Procesu] - Diagram Przepływu\n\n"

                    "' Definicja węzłów\n"
                    "(start) #LightGreen\n"
                    "<Pobranie danych wejściowych> #Yellow\n"
                    "[Walidacja danych] #LightBlue\n"
                    "{{Dane poprawne?}} #Pink\n"
                    "[Przetwarzanie główne] #LightBlue\n"
                    "[Obsługa błędów] #Orange\n"
                    "{{Powtórzyć proces?}} #Pink\n"
                    "[Generowanie wyniku] #LightBlue\n"
                    ">Raport końcowy] #Yellow\n"
                    "[(Zapis do bazy)] #LightGray\n"
                    "(end_success) #LightGreen\n"
                    "(end_error) #Red\n\n"

                    "' Główny przepływ\n"
                    "(start) ==> <Pobranie danych wejściowych> : \"Inicjalizacja\"\n"
                    "<Pobranie danych wejściowych> --> [Walidacja danych]\n"
                    "[Walidacja danych] --> {{Dane poprawne?}}\n\n"

                    "' Ścieżka sukcesu\n"
                    "{{Dane poprawne?}} --> [Przetwarzanie główne] : \"TAK\"\n"
                    "[Przetwarzanie główne] --> [Generowanie wyniku]\n"
                    "[Generowanie wyniku] --> >Raport końcowy]\n"
                    ">Raport końcowy] --> [(Zapis do bazy)]\n"
                    "[(Zapis do bazy)] --> (end_success)\n\n"

                    "' Ścieżka błędu z pętlą\n"
                    "{{Dane poprawne?}} --> [Obsługa błędów] : \"NIE\"\n"
                    "[Obsługa błędów] --> {{Powtórzyć proces?}}\n"
                    "{{Powtórzyć proces?}} --> <Pobranie danych wejściowych> : \"TAK\"\n"
                    "{{Powtórzyć proces?}} --> (end_error) : \"NIE\"\n\n"

                    "' Grupowanie obszarów\n"
                    "package \"Obszar Walidacji\" {{\n"
                    "  [Walidacja danych]\n"
                    "  {{Dane poprawne?}}\n"
                    "  [Obsługa błędów]\n"
                    "}}\n\n"

                    "package \"Obszar Przetwarzania\" {{\n"
                    "  [Przetwarzanie główne]\n"
                    "  [Generowanie wyniku]\n"
                    "}}\n\n"

                    "' Notatki wyjaśniające\n"
                    "note right of [Przetwarzanie główne]\n"
                    "  Główna logika biznesowa\n"
                    "  może wymagać dodatkowych\n"
                    "  zasobów systemowych\n"
                    "end note\n\n"

                    "note bottom of {{Powtórzyć proces?}}\n"
                    "  Maksymalnie 3 próby\n"
                    "  przed końcowym błędem\n"
                    "end note\n\n"

                    "@enduml\n"
                    "```\n\n"

                    "**ZASADY NAZEWNICTWA:**\n"
                    "- Nazwy węzłów powinny być opisowe i odzwierciedlać funkcję biznesową\n"
                    "- Używaj czasowników dla procesów (\"Oblicz\", \"Sprawdź\", \"Wygeneruj\")\n"
                    "- Używaj rzeczowników dla danych (\"Raport\", \"Dane klienta\")\n"
                    "- Decyzje formułuj jako pytania (\"Czy autoryzowany?\", \"Limit przekroczony?\")\n"
                    "- Etykiety połączeń powinny wyjaśniać warunki lub typy danych\n"
                    "- Zachowaj konsekwentność języka (polski lub angielski)\n\n"

                    "**ZASADY UKŁADU:**\n"
                    "- Główny przepływ powinien być wertykalny (góra-dół)\n"
                    "- Alternatywne ścieżki na boki\n"
                    "- Grupuj logicznie powiązane elementy\n"
                    "- Minimalizuj skrzyżowania linii\n"
                    "- Używaj kolorów dla łatwiejszego śledzenia przepływu\n"
                    "- Umieszczaj notatki przy skomplikowanych węzłach\n\n"

                    "**KOŃCOWY REZULTAT:**\n"
                    "Dostarcz kompletny, działający kod PlantUML który:\n"
                    "1. Pokazuje kompletny przepływ procesu biznesowego\n"
                    "2. Zawiera wszystkie punkty decyzyjne z warunkami\n"
                    "3. Uwzględnia alternatywne ścieżki i obsługę błędów\n"
                    "4. Używa odpowiednich kształtów dla różnych typów operacji\n"
                    "5. Zawiera logiczne grupowanie elementów\n"
                    "6. Jest wizualnie czytelny i logicznie uporządkowany\n"
                    "7. Zawiera notatki wyjaśniające dla skomplikowanych elementów\n"
                    "8. Jest gotowy do użycia bez modyfikacji\n"
                    "9. Odzwierciedla rzeczywistą logikę i kolejność procesu biznesowego"
                ),
                "allowed_diagram_types": ["flowchart"],
                "type": "PlantUML"
            },
            "Diagram komponentów - Notacja C4": {
                "template": (
                    "Jako doświadczony koder PlantUML i architekt systemowy wygeneruj diagram komponentów C4 w PlantUML dla:\n{process_description}\n"
                    "z następującymi wymaganiami:\n\n"
        
                    "**WYMAGANIA TECHNICZNE C4 COMPONENT:**\n"
                    "1. **INCLUDES:** Użyj WYŁĄCZNIE:\n"
                    "   - `!include <C4/C4_Component>`\n"
                    "   - Opcjonalnie `!include <C4/C4_Container>` jeśli pokazujesz kontekst kontenerów\n\n"
        
                    "2. **DOSTĘPNE MAKRA:**\n"
                    "   - `Component(alias, \"Nazwa\", \"Technologia\", \"Opis funkcjonalności\")`\n"
                    "   - `ComponentDb(alias, \"Nazwa DB\", \"Typ DB\", \"Opis danych\")`\n"
                    "   - `ComponentQueue(alias, \"Nazwa Queue\", \"Technologia\", \"Opis kolejki\")`\n"
                    "   - `Container()` - TYLKO dla kontekstu, nie jako główne elementy\n\n"
        
                    "3. **STRUKTURA DIAGRAMU:**\n"
                    "   - Rozpocznij: `@startuml`\n"
                    "   - Include: `!include <C4/C4_Component>`\n"
                    "   - Tytuł: `title [System] - Diagram Komponentów (C4 Level 3)`\n"
                    "   - Opcjonalnie kontekst kontenera: `Container_Boundary(container, \"Kontener\")`\n"
                    "   - Definicje wszystkich komponentów\n"
                    "   - Relacje między komponentami\n"
                    "   - Zakończ: `@enduml`\n\n"
        
                    "4. **POZIOM SZCZEGÓŁOWOŚCI:**\n"
                    "   - Pokazuj komponenty WEWNĄTRZ jednego kontenera/systemu\n"
                    "   - Każdy komponent = konkretna odpowiedzialność biznesowa\n"
                    "   - NIE mieszaj poziomów abstrakcji (System vs Component)\n"
                    "   - Skupij się na przepływie danych i wywołaniach między komponentami\n\n"
        
                    "5. **RELACJE:**\n"
                    "   - `Rel(źródło, cel, \"Etykieta\", \"Protokół/Technologia\")`\n"
                    "   - `Rel_Back()`, `Rel_Neighbor()` dla lepszego layoutu\n"
                    "   - Zawsze opisuj CZYM jest komunikacja (API call, event, data flow)\n\n"
        
                    "6. **NAZEWNICTWO:**\n"
                    "   - Konsekwentny język (polski LUB angielski)\n"
                    "   - Nazwy komponentów = rzeczowniki opisujące funkcję\n"
                    "   - Aliasy = krótkie, bez spacji, snake_case lub camelCase\n\n"
        
                    "7. **PRZYKŁAD POPRAWNEJ STRUKTURY:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "!include <C4/C4_Component>\n"
                    "title System Zamówień - Komponenty (C4 Level 3)\n\n"
        
                    "Container_Boundary(api_container, \"API Container\") {{\n"
                    "    Component(order_controller, \"Order Controller\", \"Spring MVC\", \"Obsługuje żądania HTTP dla zamówień\")\n"
                    "    Component(order_service, \"Order Service\", \"Spring Bean\", \"Logika biznesowa zamówień\")\n"
                    "    Component(payment_service, \"Payment Service\", \"Spring Bean\", \"Obsługa płatności\")\n"
                    "    Component(notification_service, \"Notification Service\", \"Spring Bean\", \"Wysyłanie powiadomień\")\n"
                    "    ComponentDb(order_db, \"Orders Database\", \"PostgreSQL\", \"Przechowuje dane zamówień\")\n"
                    "    ComponentQueue(order_queue, \"Order Events\", \"RabbitMQ\", \"Kolejka zdarzeń zamówień\")\n"
                    "}}\n\n"
        
                    "Rel(order_controller, order_service, \"Wywołuje\", \"Method call\")\n"
                    "Rel(order_service, payment_service, \"Przetwarza płatność\", \"Method call\")\n"
                    "Rel(order_service, order_db, \"Zapisuje zamówienie\", \"SQL\")\n"
                    "Rel(order_service, order_queue, \"Publikuje zdarzenie\", \"AMQP\")\n"
                    "Rel(notification_service, order_queue, \"Nasłuchuje zdarzeń\", \"AMQP\")\n"
                    "@enduml\n"
                    "```\n\n"
        
                    "8. **ZABRONIONE PRAKTYKI:**\n"
                    "   - ❌ Mieszanie makr z różnych poziomów C4\n"
                    "   - ❌ Używanie `System()` w diagramie komponentów\n"
                    "   - ❌ Pokazywanie komponentów z różnych kontenerów bez kontekstu\n"
                    "   - ❌ Niejasne nazwy typu \"Service1\", \"Database\"\n"
                    "   - ❌ Relacje bez opisów technologii komunikacji\n\n"
        
                    "**REZULTAT:** Wygeneruj kompletny, działający kod PlantUML przedstawiający komponenty wewnątrz systemu/kontenera zgodnie z poziomem 3 modelu C4."
                ),
                "allowed_diagram_types": ["component"],
                "type": "PlantUML"
            },
            "Diagram komponentów - Podstawowa notacja": {
                "template": (
                    "Na podstawie opisu procesu biznesowego: {process_description}\n\n"
        
                    "**KROK 1: ANALIZA PROCESU BIZNESOWEGO**\n"
                    "Przeanalizuj opisany proces i zidentyfikuj:\n"
                    "- Jakie dane są przetwarzane, przechowywane, przekazywane?\n"
                    "- Jakie decyzje są podejmowane i na podstawie czego?\n"
                    "- Jakie systemy zewnętrzne są wymagane?\n"
                    "- Jakie powiadomienia/komunikacja jest potrzebna?\n"
                    "- Jakie dokumenty/raporty są generowane?\n\n"

                    "**KROK 2: IDENTYFIKACJA KOMPONENTÓW SYSTEMU**\n"
                    "Na podstawie analizy określ jakie komponenty informatyczne są potrzebne:\n\n"
        
                    "**A) WARSTWA INTERFEJSU UŻYTKOWNIKA:**\n"
                    "- Czy potrzebna jest aplikacja webowa?\n"
                    "- Czy potrzebne jest API dla innych systemów?\n"
                    "- Czy potrzebny jest panel administracyjny?\n"
                    "- Czy potrzebne są mobilne interfejsy?\n\n"
        
                    "**B) WARSTWA LOGIKI BIZNESOWEJ:**\n"
                    "- Jakie serwisy biznesowe obsługują główne funkcje procesu?\n"
                    "- Czy potrzebne są komponenty do walidacji danych?\n"
                    "- Czy potrzebne są komponenty do obliczeń/algorytmów?\n"
                    "- Czy potrzebne są komponenty do orkiestracji przepływu?\n\n"
        
                    "**C) WARSTWA DOSTĘPU DO DANYCH:**\n"
                    "- Jakie bazy danych są potrzebne (transakcyjne, analityczne)?\n"
                    "- Czy potrzebne są repozytoria/DAO?\n"
                    "- Czy potrzebna jest cache/pamięć podręczna?\n"
                    "- Czy potrzebne są komponenty ETL?\n\n"
        
                    "**D) KOMPONENTY INTEGRACYJNE:**\n"
                    "- Z jakimi systemami zewnętrznymi trzeba się integrować?\n"
                    "- Czy potrzebne są kolejki/brokery komunikatów?\n"
                    "- Czy potrzebne są komponenty do synchronizacji danych?\n"
                    "- Czy potrzebne są adaptery/connectors?\n\n"
        
                    "**E) KOMPONENTY POMOCNICZE:**\n"
                    "- Czy potrzebne są komponenty do powiadomień (email, SMS)?\n"
                    "- Czy potrzebne są komponenty do generowania raportów?\n"
                    "- Czy potrzebne są komponenty do logowania/audytu?\n"
                    "- Czy potrzebne są komponenty do zarządzania plikami?\n\n"
        
                    "**KROK 3: GENEROWANIE DIAGRAMU PlantUML**\n"
                    "Wygeneruj kompletny kod PlantUML w podstawowej notacji z następującymi wymaganiami:\n\n"
        
                    "**STRUKTURA TECHNICZNA:**\n"
                    "1. **Rozpocznij:** `@startuml`\n"
                    "2. **Tytuł:** `title [Nazwa Procesu] - Architektura Systemu`\n"
                    "3. **Definicje wszystkich elementów przed relacjami**\n"
                    "4. **Zakończ:** `@enduml`\n\n"
        
                    "**ELEMENTY DO UŻYCIA:**\n"
                    "- `actor \"Nazwa\" as alias` - użytkownicy/role\n"
                    "- `component \"Nazwa\" <<stereotype>> as alias` - komponenty biznesowe\n"
                    "- `database \"Nazwa\" as alias` - bazy danych\n"
                    "- `queue \"Nazwa\" as alias` - kolejki/brokery\n"
                    "- `file \"Nazwa\" as alias` - storage/pliki\n"
                    "- `cloud \"Nazwa\" as alias` - systemy zewnętrzne\n"
                    "- `interface \"Nazwa\" as alias` - interfejsy\n\n"
        
                    "**GRUPOWANIE:**\n"
                    "- `package \"UI Layer\" {{ }}` - warstwa interfejsu\n"
                    "- `package \"Business Layer\" {{ }}` - logika biznesowa\n"
                    "- `package \"Data Layer\" {{ }}` - dostęp do danych\n"
                    "- `package \"Integration Layer\" {{ }}` - integracje\n"
                    "- `frame \"[Nazwa Systemu]\" {{ }}` - granice systemu\n\n"
        
                    "**STEREOTYPY:**\n"
                    "- `<<controller>>` - kontrolery Web/API\n"
                    "- `<<service>>` - serwisy biznesowe\n"
                    "- `<<repository>>` - dostęp do danych\n"
                    "- `<<facade>>` - fasady integracyjne\n"
                    "- `<<utility>>` - komponenty pomocnicze\n"
                    "- `<<gateway>>` - bramy API\n\n"
        
                    "**RELACJE Z OPISAMI:**\n"
                    "- `-->` z etykietami typu: \"HTTP API\", \"SQL Query\", \"Message\", \"File Access\"\n"
                    "- Zawsze opisuj protokół/technologię komunikacji\n"
                    "- Grupuj podobne relacje dla czytelności\n\n"
        
                    "**PRZYKŁAD STRUKTURY:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "title [Nazwa Procesu] - Architektura Systemu\n\n"
        
                    "' Aktorzy z procesu biznesowego\n"
                    "actor \"[Rola1]\" as actor1\n"
                    "actor \"[Rola2]\" as actor2\n\n"
        
                    "' Systemy zewnętrzne zidentyfikowane w procesie\n"
                    "cloud \"[System Zewnętrzny]\" as ext_system\n\n"
        
                    "frame \"System [Nazwa Procesu]\" {{\n"
                    "    package \"UI Layer\" {{\n"
                    "        component \"[Process] Web App\" <<controller>> as web_app\n"
                    "        component \"[Process] API\" <<gateway>> as api\n"
                    "    }}\n\n"
        
                    "    package \"Business Layer\" {{\n"
                    "        component \"[Process] Service\" <<service>> as main_service\n"
                    "        component \"[Function] Service\" <<service>> as func_service\n"
                    "        interface \"I[Process]Service\" as iservice\n"
                    "    }}\n\n"
        
                    "    package \"Data Layer\" {{\n"
                    "        component \"[Entity] Repository\" <<repository>> as repo\n"
                    "        database \"[Process] Database\" as db\n"
                    "    }}\n\n"
        
                    "    package \"Integration Layer\" {{\n"
                    "        component \"[External] Adapter\" <<facade>> as adapter\n"
                    "        queue \"[Process] Events\" as queue\n"
                    "    }}\n"
                    "}}\n\n"
        
                    "' Relacje wyprowadzone z przepływu procesu\n"
                    "actor1 --> web_app : \"Inicjuje proces\"\n"
                    "web_app --> iservice : \"Wywołuje logikę\"\n"
                    "main_service ..|> iservice : \"implements\"\n"
                    "main_service --> repo : \"Pobiera/zapisuje dane\"\n"
                    "repo --> db : \"SQL\"\n"
                    "main_service --> adapter : \"Integracja zewnętrzna\"\n"
                    "adapter --> ext_system : \"API call\"\n"
                    "@enduml\n"
                    "```\n\n"
        
                    "**ZASADY NAZEWNICTWA:**\n"
                    "- Nazwy komponentów powinny odzwierciedlać funkcje z procesu biznesowego\n"
                    "- Używaj nazw funkcjonalnych, nie technicznych (\"Order Service\" zamiast \"Service1\")\n"
                    "- Aliasy krótkie, bez spacji (order_service, payment_api)\n"
                    "- Konsekwentny język (polski lub angielski)\n\n"
        
                    "**KOŃCOWY REZULTAT:**\n"
                    "Dostarcz kompletny, działający kod PlantUML który:\n"
                    "1. Odzwierciedla wszystkie aspekty procesu biznesowego w formie komponentów IT\n"
                    "2. Pokazuje logiczną architekturę systemu potrzebnego do obsługi procesu\n"
                    "3. Zawiera wszystkie niezbędne integracje i przepływy danych\n"
                    "4. Jest gotowy do użycia bez modyfikacji\n"
                    "5. Zawiera komentarze wyjaśniające mapowanie proces→komponenty"
                ),
                "allowed_diagram_types": ["component"],
                "type": "PlantUML"
            },      
            "Diagram wdrożeniowy": {
                "template": (
                    "Na podstawie opisu procesu biznesowego: {process_description}\n\n"

                    "**KROK 1: ANALIZA WYMAGAŃ INFRASTRUKTURALNYCH PROCESU**\n"
                    "Przeanalizuj opisany proces i zidentyfikuj:\n"
                    "- Ile użytkowników jednocześnie będzie korzystać z systemu?\n"
                    "- Jakie są wymagania wydajnościowe i dostępności?\n"
                    "- Czy proces wymaga przetwarzania w czasie rzeczywistym?\n"
                    "- Jakie dane są przetwarzane i jak duże są wolumeny?\n"
                    "- Czy są wymagania bezpieczeństwa i compliance?\n"
                    "- Czy proces integruje się z systemami zewnętrznymi?\n"
                    "- Jakie są wymagania geograficzne/lokalizacyjne?\n"
                    "- Czy potrzebna jest skalowalność i elastyczność?\n\n"

                    "**KROK 2: IDENTYFIKACJA ELEMENTÓW INFRASTRUKTURY**\n"
                    "Na podstawie analizy określ elementy wdrożeniowe:\n\n"

                    "**A) WĘZŁY WYKONAWCZE (EXECUTION NODES):**\n"
                    "- Czy potrzebne są serwery aplikacyjne?\n"
                    "- Ile instancji aplikacji jest wymaganych?\n"
                    "- Czy potrzebne są serwery bazodanowe?\n"
                    "- Czy wymagane są serwery cache/pamięci?\n"
                    "- Czy potrzebne są serwery kolejek/brokerów?\n\n"

                    "**B) URZĄDZENIA UŻYTKOWNIKÓW (CLIENT DEVICES):**\n"
                    "- Jakie typy urządzeń będą używane (PC, mobile, tablet)?\n"
                    "- Czy potrzebne są aplikacje desktopowe?\n"
                    "- Czy wystarczą przeglądarki webowe?\n"
                    "- Czy potrzebne są aplikacje mobilne?\n\n"

                    "**C) INFRASTRUKTURA SIECIOWA:**\n"
                    "- Jakie są wymagania dotyczące sieci (LAN, WAN, Internet)?\n"
                    "- Czy potrzebne są load balancery?\n"
                    "- Czy wymagane są firewalle/proxy?\n"
                    "- Czy potrzebne są VPN/bezpieczne połączenia?\n\n"

                    "**D) INFRASTRUKTURA CHMUROWA:**\n"
                    "- Czy proces będzie wdrożony w chmurze?\n"
                    "- Jakie usługi chmurowe są potrzebne?\n"
                    "- Czy wymagane są kontenery/orkiestracja?\n"
                    "- Czy potrzebne są CDN/usługi dystrybucji?\n\n"

                    "**E) SYSTEMY WSPIERAJĄCE:**\n"
                    "- Czy potrzebne są systemy monitorowania?\n"
                    "- Czy wymagane są systemy backup/disaster recovery?\n"
                    "- Czy potrzebne są systemy logowania/audytu?\n"
                    "- Czy wymagane są systemy CI/CD?\n\n"

                    "**KROK 3: MAPOWANIE KOMPONENTÓW NA INFRASTRUKTURĘ**\n"
                    "Określ jak komponenty systemu będą rozmieszczone:\n\n"

                    "**A) WARSTWA PREZENTACJI:**\n"
                    "- Gdzie będą działać interfejsy użytkownika?\n"
                    "- Jak będą dystrybuowane aplikacje klienckie?\n"
                    "- Gdzie będą serwowane zasoby statyczne?\n\n"

                    "**B) WARSTWA APLIKACYJNA:**\n"
                    "- Na których serwerach będą działać serwisy biznesowe?\n"
                    "- Jak będzie zapewniona wysoka dostępność?\n"
                    "- Gdzie będą działać komponenty integracyjne?\n\n"

                    "**C) WARSTWA DANYCH:**\n"
                    "- Gdzie będą przechowywane dane transakcyjne?\n"
                    "- Gdzie będą dane analityczne/historyczne?\n"
                    "- Jak będzie zapewniona replikacja/backup?\n\n"

                    "**KROK 4: GENEROWANIE DIAGRAMU PlantUML**\n"
                    "Wygeneruj kompletny kod PlantUML w notacji wdrożeniowej z następującymi wymaganiami:\n\n"

                    "**STRUKTURA TECHNICZNA:**\n"
                    "1. **Rozpocznij:** `@startuml`\n"
                    "2. **Tytuł:** `title [Nazwa Procesu] - Architektura Wdrożeniowa`\n"
                    "3. **Definicje węzłów przed artefaktami**\n"
                    "4. **Grupowanie logiczne środowisk**\n"
                    "5. **Zakończ:** `@enduml`\n\n"

                    "**WĘZŁY INFRASTRUKTURALNE:**\n"
                    "- `node \"Nazwa\" as alias` - serwery fizyczne/wirtualne\n"
                    "- `cloud \"Nazwa\" as alias` - usługi chmurowe\n"
                    "- `database \"Nazwa\" as alias` - serwery bazodanowe\n"
                    "- `queue \"Nazwa\" as alias` - serwery kolejek\n"
                    "- `storage \"Nazwa\" as alias` - systemy przechowywania\n"
                    "- `file \"Nazwa\" as alias` - systemy plików\n\n"

                    "**URZĄDZENIA I KLIENCI:**\n"
                    "- `actor \"Nazwa\" as alias` - użytkownicy\n"
                    "- `node \"PC\" <<device>> as alias` - komputery\n"
                    "- `node \"Mobile\" <<mobile>> as alias` - urządzenia mobilne\n"
                    "- `node \"Browser\" <<browser>> as alias` - przeglądarki\n\n"

                    "**ARTEFAKTY WDROŻENIOWE:**\n"
                    "- `artifact \"Nazwa.war\" as alias` - aplikacje webowe\n"
                    "- `artifact \"Nazwa.jar\" as alias` - aplikacje Java\n"
                    "- `artifact \"Nazwa.exe\" as alias` - aplikacje desktopowe\n"
                    "- `artifact \"Nazwa.js\" as alias` - aplikacje JavaScript\n"
                    "- `artifact \"Nazwa.apk\" as alias` - aplikacje mobilne\n\n"

                    "**INFRASTRUKTURA SIECIOWA:**\n"
                    "- `node \"Load Balancer\" <<lb>> as alias` - równoważenie obciążenia\n"
                    "- `node \"Firewall\" <<fw>> as alias` - zabezpieczenia sieciowe\n"
                    "- `node \"Proxy\" <<proxy>> as alias` - serwery proxy\n"
                    "- `node \"CDN\" <<cdn>> as alias` - sieci dostarczania treści\n\n"

                    "**GRUPOWANIE I ŚRODOWISKA:**\n"
                    "- `package \"Production\" {{ }}` - środowisko produkcyjne\n"
                    "- `package \"Staging\" {{ }}` - środowisko testowe\n"
                    "- `package \"Development\" {{ }}` - środowisko deweloperskie\n"
                    "- `frame \"Data Center\" {{ }}` - centra danych\n"
                    "- `rectangle \"AWS/Azure\" {{ }}` - chmury publiczne\n\n"

                    "**RELACJE I PROTOKOŁY:**\n"
                    "- `-->` z etykietami protokołów: \"HTTPS\", \"TCP/IP\", \"REST API\", \"gRPC\"\n"
                    "- `..>` dla relacji deployment\n"
                    "- `==>` dla przepływów danych\n"
                    "- Zawsze opisuj protokoły komunikacji i porty\n\n"

                    "**PRZYKŁAD STRUKTURY:**\n"
                    "```plantuml\n"
                    "@startuml\n"
                    "title [Nazwa Procesu] - Architektura Wdrożeniowa\n\n"

                    "' Użytkownicy i urządzenia klienckie\n"
                    "actor \"[Rola Użytkownika]\" as user\n"
                    "node \"Przeglądarka\" <<browser>> as browser\n"
                    "node \"Aplikacja Mobilna\" <<mobile>> as mobile_app\n\n"

                    "' Infrastruktura sieciowa\n"
                    "node \"Load Balancer\" <<lb>> as lb\n"
                    "node \"Firewall\" <<fw>> as firewall\n"
                    "cloud \"CDN\" <<cdn>> as cdn\n\n"

                    "frame \"Centrum Danych\" {{\n\n"

                    "    package \"Środowisko Produkcyjne\" {{\n\n"

                    "        ' Warstwa aplikacyjna\n"
                    "        node \"Serwer App 1\" <<server>> as app_server1 {{\n"
                    "            artifact \"[Process].war\" as web_app\n"
                    "            artifact \"[Process]-api.jar\" as api_service\n"
                    "        }}\n\n"

                    "        node \"Serwer App 2\" <<server>> as app_server2 {{\n"
                    "            artifact \"[Process].war\" as web_app2\n"
                    "            artifact \"[Process]-api.jar\" as api_service2\n"
                    "        }}\n\n"

                    "        ' Warstwa danych\n"
                    "        database \"Baza Główna\" <<primary>> as main_db {{\n"
                    "            artifact \"[Process] Database\" as db_schema\n"
                    "        }}\n\n"

                    "        database \"Baza Replika\" <<replica>> as replica_db {{\n"
                    "            artifact \"[Process] Database\" as db_replica\n"
                    "        }}\n\n"

                    "        ' Systemy kolejek\n"
                    "        queue \"Message Broker\" as message_queue {{\n"
                    "            artifact \"[Process] Events\" as event_queue\n"
                    "        }}\n\n"

                    "        ' Cache\n"
                    "        node \"Redis Cache\" <<cache>> as cache {{\n"
                    "            artifact \"Session Store\" as sessions\n"
                    "            artifact \"Data Cache\" as data_cache\n"
                    "        }}\n\n"

                    "        ' Storage\n"
                    "        storage \"File Storage\" as file_storage {{\n"
                    "            artifact \"[Process] Documents\" as documents\n"
                    "            artifact \"System Logs\" as logs\n"
                    "        }}\n"
                    "    }}\n\n"

                    "    ' Systemy zewnętrzne\n"
                    "    cloud \"[System Zewnętrzny]\" <<external>> as external_system\n"
                    "}}\n\n"

                    "' Połączenia użytkowników\n"
                    "user --> browser : \"Używa\"\n"
                    "user --> mobile_app : \"Używa\"\n\n"

                    "' Przepływ ruchu\n"
                    "browser --> cdn : \"HTTPS/443\"\n"
                    "cdn --> firewall : \"HTTPS/443\"\n"
                    "firewall --> lb : \"HTTPS/443\"\n"
                    "mobile_app --> firewall : \"HTTPS/443\"\n\n"

                    "' Load balancing\n"
                    "lb --> app_server1 : \"HTTP/8080\"\n"
                    "lb --> app_server2 : \"HTTP/8080\"\n\n"

                    "' Komunikacja aplikacji z bazami\n"
                    "web_app --> main_db : \"JDBC/5432\"\n"
                    "web_app2 --> main_db : \"JDBC/5432\"\n"
                    "api_service --> main_db : \"JDBC/5432\"\n"
                    "api_service2 --> main_db : \"JDBC/5432\"\n\n"

                    "' Replikacja bazy danych\n"
                    "main_db ==> replica_db : \"Replikacja\"\n\n"

                    "' Cache i kolejki\n"
                    "web_app --> cache : \"Redis/6379\"\n"
                    "web_app2 --> cache : \"Redis/6379\"\n"
                    "api_service --> message_queue : \"AMQP/5672\"\n"
                    "api_service2 --> message_queue : \"AMQP/5672\"\n\n"

                    "' Storage\n"
                    "web_app --> file_storage : \"NFS/2049\"\n"
                    "web_app2 --> file_storage : \"NFS/2049\"\n\n"

                    "' Integracje zewnętrzne\n"
                    "api_service --> external_system : \"REST API/HTTPS\"\n"
                    "api_service2 --> external_system : \"REST API/HTTPS\"\n\n"

                    "' Notatki techniczne\n"
                    "note right of lb : \"Nginx Load Balancer\\nActive-Active\"\n"
                    "note bottom of main_db : \"PostgreSQL 13\\nMaster-Slave Setup\"\n"
                    "note left of cache : \"Redis Cluster\\n3 nodes\"\n\n"

                    "@enduml\n"
                    "```\n\n"

                    "**ZASADY NAZEWNICTWA:**\n"
                    "- Nazwy węzłów opisują funkcję infrastrukturalną (\"Serwer Aplikacyjny\", \"Baza Główna\")\n"
                    "- Nazwy artefaktów zawierają technologię/format (\"app.war\", \"service.jar\")\n"
                    "- Aliasy krótkie, techniczne (app_server, main_db, lb)\n"
                    "- Konsekwentny język (polski lub angielski)\n"
                    "- Uwzględnianie wersji technologii w notatkach\n\n"

                    "**ZASADY MODELOWANIA INFRASTRUKTURALNEGO:**\n"
                    "- Każdy węzeł reprezentuje fizyczny lub wirtualny zasób\n"
                    "- Artefakty pokazują co jest wdrożone na węzłach\n"
                    "- Relacje zawierają protokoły i porty komunikacji\n"
                    "- Grupowanie według środowisk i lokalizacji\n"
                    "- Uwzględnianie aspektów bezpieczeństwa i dostępności\n"
                    "- Pokazywanie replikacji i redundancji\n\n"

                    "**KOŃCOWY REZULTAT:**\n"
                    "Dostarcz kompletny, działający kod PlantUML który:\n"
                    "1. Odzwierciedla fizyczną architekturę potrzebną do obsługi procesu\n"
                    "2. Pokazuje rozmieszczenie komponentów na infrastrukturze\n"
                    "3. Zawiera wszystkie protokoły komunikacji i porty\n"
                    "4. Uwzględnia wymagania wydajności, dostępności i bezpieczeństwa\n"
                    "5. Jest gotowy do użycia bez modyfikacji\n"
                    "6. Zawiera komentarze wyjaśniające mapowanie proces→infrastruktura\n"
                    "7. Prezentuje perspektywę operacyjną wdrożenia systemu"
                ),
                "allowed_diagram_types": ["deployment"],
                "type": "PlantUML"
            },            
            "BPMN - podstawowy": {
                "template": (
                    "**Jako doświadczony analityk biznesowy i architekt procesów z 10-letnim stażem w notacji BPMN 2.0, Twoim zadaniem jest wygenerowanie kompletnego kodu XML diagramu procesu biznesowego na podstawie poniższego opisu:**\n\n"
                    "{process_description}\n\n"
                    "**ANALIZA PROCESU:**\n"
                    "1. Zidentyfikuj wszystkich uczestników procesu (Pools/Participants).\n"
                    "2. Zidentyfikuj role lub systemy w ramach uczestników (Lanes).\n"
                    "3. Określ dokładną sekwencję kroków i wszystkie punkty decyzyjne (Gateways).\n"
                    "4. Wyłap wszystkie interakcje (Message Flows) między uczestnikami.\n"
                    "5. Uwzględnij scenariusze wyjątkowe i obsługę błędów (Error/Timer Events).\n\n"
                    "**WYMAGANIA TECHNICZNE (XML):**\n"
                    "- Format: Kompletny, walidujący się kod XML BPMN 2.0.\n"
                    "- Kompatybilność: Gotowy do bezpośredniego importu i renderowania w Camunda Modeler 5.x.\n"
                    "- **Przestrzenie nazw:** MUSISZ użyć pełnych definicji xmlns, w tym dla 'camunda':\n"
                    "  ```xml\n"
                    "  <definitions xmlns=\"[http://www.omg.org/spec/BPMN/20100524/MODEL](http://www.omg.org/spec/BPMN/20100524/MODEL)\"\n"
                    "             xmlns:bpmndi=\"[http://www.omg.org/spec/BPMN/20100524/DI](http://www.omg.org/spec/BPMN/20100524/DI)\"\n"
                    "             xmlns:omgdc=\"[http://www.omg.org/spec/DD/20100524/DC](http://www.omg.org/spec/DD/20100524/DC)\"\n"
                    "             xmlns:omgdi=\"[http://www.omg.org/spec/DD/20100524/DI](http://www.omg.org/spec/DD/20100524/DI)\"\n"
                    "             xmlns:camunda=\"[http://camunda.org/schema/1.0/bpmn](http://camunda.org/schema/1.0/bpmn)\"\n"
                    "             targetNamespace=\"[http://bpmn.io/schema/bpmn](http://bpmn.io/schema/bpmn)\"\n"
                    "             id=\"Definitions_1\">\n"
                    "  ```\n"
                    "- **Struktura semantyczna:** Musi zawierać sekcje `<collaboration>` (z `<participant>`) oraz `<process>`. \n"
                    "- **Powiązanie ProcessRef:** Każdy `<participant>` w `<collaboration>` MUSI być powiązany z odpowiednim `<process>` poprzez atrybut `processRef` (np. `<participant id=\"Pool_1\" processRef=\"Process_1\" />`).\n"
                    "- **Wykonywalność:** Główny proces powinien być oznaczony jako `isExecutable=\"true\"`.\n\n"
                    "**KRYTYCZNE WYMAGANIA DIAGRAM INTERCHANGE (DI):**\n"
                    "> To jest najważniejsza sekcja, aby diagram nie był pusty. Każdy element semantyczny musi mieć 1-do-1 odpowiednik wizualny.\n\n"
                    "1.  **Powiązanie `bpmnElement`:** Każdy element semantyczny (np. `<task id=\"Task_1\">`, `<sequenceFlow id=\"Flow_1\">`, `<participant id=\"Pool_1\">`) MUSI mieć swój dokładny odpowiednik wizualny w sekcji `<bpmndi:BPMNPlane>` powiązany atrybutem `bpmnElement`.\n"
                    "    - Dla Kształtów (Task, Event, Gateway, Pool, Lane): `<bpmndi:BPMNShape bpmnElement=\"ID_Elementu_Semantycznego\">`\n"
                    "    - Dla Krawędzi (Flows): `<bpmndi:BPMNEdge bpmnElement=\"ID_Elementu_Semantycznego\">`\n"
                    "2.  **Współrzędne (Shapes):** Każdy `<bpmndi:BPMNShape>` MUSI zawierać element `<omgdc:Bounds>` z kompletnymi, logicznie rozmieszczonymi współrzędnymi (`x`, `y`, `width`, `height`).\n"
                    "3.  **Punkty (Edges):** Każdy `<bpmndi:BPMNEdge>` (dla Sequence i Message Flow) MUSI zawierać co najmniej dwa elementy `<omgdi:waypoint>` definiujące jego punkty (początek i koniec).\n"
                    "4.  **Powiązanie Plane:** Element `<bpmndi:BPMNPlane>` MUSI być powiązany z główną kolaboracją (np. `<bpmndi:BPMNPlane bpmnElement=\"Collaboration_1\">`).\n\n"
                    "**WYMAGANIA JAKOŚCI:**\n"
                    "- Wszystkie elementy muszą mieć unikalne ID (np. `StartEvent_1`, `Activity_0xj3f8s`, `Flow_123`).\n"
                    "- Wszystkie elementy widoczne dla użytkownika (Task, Event, Pool) muszą mieć czytelną etykietę (atrybut `name`).\n"
                    "- Dla `UserTask` dodaj atrybut `camunda:assignee` lub `camunda:candidateGroups`.\n"
                    "- Dla `ServiceTask` dodaj atrybut `camunda:topic` lub `camunda:class`.\n\n"
                    "**WZORCOWA STRUKTURA MINIMALNEGO POPRAWNEGO PLIKU (Schemat powiązań):**\n"
                    "```xml\n"
                    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
                    "<definitions ... (wszystkie namespaces) ...>\n"
                    "\n"
                    "  \n"
                    "  <collaboration id=\"Collaboration_1\">\n"
                    "    \n"
                    "    <participant id=\"Participant_1\" name=\"Uczestnik\" processRef=\"Process_1\" />\n"
                    "  </collaboration>\n"
                    "\n"
                    "  <process id=\"Process_1\" isExecutable=\"true\">\n"
                    "    <startEvent id=\"StartEvent_1\" name=\"Start\">\n"
                    "      <outgoing>Flow_1</outgoing>\n"
                    "    </startEvent>\n"
                    "    <sequenceFlow id=\"Flow_1\" sourceRef=\"StartEvent_1\" targetRef=\"Task_1\" />\n"
                    "    <userTask id=\"Task_1\" name=\"Zadanie\" camunda:assignee=\"demo\">\n"
                    "      <incoming>Flow_1</incoming>\n"
                    "    </userTask>\n"
                    "  </process>\n"
                    "\n"
                    "  \n"
                    "  <bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">\n"
                    "    \n"
                    "    <bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Collaboration_1\">\n"
                    "      \n"
                    "      \n"
                    "      \n"
                    "      <bpmndi:BPMNShape id=\"Participant_1_di\" bpmnElement=\"Participant_1\" isHorizontal=\"true\">\n"
                    "        <omgdc:Bounds x=\"160\" y=\"80\" width=\"600\" height=\"250\" />\n"
                    "      </bpmndi:BPMNShape>\n"
                    "      \n"
                    "      \n"
                    "      \n"
                    "      <bpmndi:BPMNShape id=\"StartEvent_1_di\" bpmnElement=\"StartEvent_1\">\n"
                    "        <omgdc:Bounds x=\"210\" y=\"182\" width=\"36\" height=\"36\" />\n"
                    "        <bpmndi:BPMNLabel>\n"
                    "          <omgdc:Bounds x=\"218\" y=\"225\" width=\"27\" height=\"14\" />\n"
                    "        </bpmndi:BPMNLabel>\n"
                    "      </bpmndi:BPMNShape>\n"
                    "      \n"
                    "      \n"
                    "      <bpmndi:BPMNShape id=\"Task_1_di\" bpmnElement=\"Task_1\">\n"
                    "        <omgdc:Bounds x=\"300\" y=\"160\" width=\"100\" height=\"80\" />\n"
                    "      </bpmndi:BPMNShape>\n"
                    "      \n"
                    "      \n"
                    "      \n"
                    "      <bpmndi:BPMNEdge id=\"Flow_1_di\" bpmnElement=\"Flow_1\">\n"
                    "        <omgdi:waypoint x=\"246\" y=\"200\" />\n"
                    "        <omgdi:waypoint x=\"300\" y=\"200\" />\n"
                    "      </BPMNEdge>\n"
                    "      \n"
                    "    </bpmndi:BPMNPlane>\n"
                    "  </bpmndi:BPMNDiagram>\n"
                    "</definitions>\n"
                    "```\n\n"
                    "**REZULTAT:** Dostarcz TYLKO kompletny, działający kod XML BPMN 2.0 bez żadnych dodatkowych komentarzy i wyjaśnień poza kodem. Kod musi być gotowy do zapisu jako plik `.bpmn` i otwarcia w Camunda Modeler.\n"
                ),
                "allowed_diagram_types": ["BPMN"],
                "type": "XML"
            },
            "BPMN - zaawansowany": {
                "template": (
                    "**Jako senior architekt procesów biznesowych z certyfikacją BPMN 2.0, przeanalizuj proces i stwórz profesjonalny diagram:**\n\n"
                    "{process_description}\n\n"
                    "**DEEP ANALYSIS:**\n"
                    "1. **Stakeholder Mapping**: Zidentyfikuj wszystkich interesariuszy\n"
                    "2. **Process Decomposition**: Rozbij na sub-procesy gdzie sensowne\n"
                    "3. **Exception Handling**: Uwzględnij wszystkie scenariusze wyjątkowe\n"
                    "4. **Compliance**: Dodaj punkty kontrolne i audytu\n\n"
                    "**ENTERPRISE REQUIREMENTS:**\n"
                    "- **Governance**: Dodaj właściciela procesu i role RACI\n"
                    "- **Monitoring**: Uwzględnij KPI i punkty pomiarowe\n"
                    "- **Integration**: Określ punkty integracji z innymi systemami\n"
                    "- **Security**: Dodaj punkty bezpieczeństwa i autoryzacji\n\n"
                    "**ADVANCED ELEMENTS:**\n"
                    "- **Sub-processes**: Dla złożonych operacji\n"
                    "- **Call Activities**: Dla procesów wielokrotnego użytku\n"
                    "- **Event Sub-processes**: Dla obsługi wyjątków\n"
                    "- **Compensation**: Dla transakcji wymagających cofnięcia\n\n"
                    "**QUALITY GATES:**\n"
                    "- Walidacja poprawności syntaktycznej\n"
                    "- Sprawdzenie kompletności przepływu\n"
                    "- Weryfikacja logiki biznesowej\n"
                    "- Test importu do Camunda Modeler\n\n"
                    "**OUTPUT:** Kompletny, enterprise-ready XML BPMN 2.0"
                ),
                "allowed_diagram_types": ["BPMN"],
                "type": "XML"
            },
            "BPMN - domena bankowa": {
                "template": (
                    "**Jako ekspert branżowy w dziedzinie {domain} z 15-letnim doświadczeniem w procesach BPMN, przygotuj diagram zgodny z najlepszymi praktykami sektora:**\n\n"
                    "{process_description}\n\n"
                    "**DOMAIN EXPERTISE:**\n"
                    "- Uwzględnij specyficzne wymagania branżowe\n"
                    "- Zastosuj standardowe wzorce procesowe dla {domain}\n"
                    "- Zachowaj zgodność z regulacjami sektorowymi\n"
                    "- Użyj standardowej terminologii branżowej\n\n"
                    "**BRANŻOWE WZORCE:**\n"
                    "- Finansowe: AML, KYC, PCI DSS, GDPR\n"
                    "- Medyczne: HIPAA, FDA, GxP\n"
                    "- Produkcyjne: ISO 9001, Lean, Six Sigma\n"
                    "- E-commerce: PCI DSS, GDPR, Consumer Protection\n\n"
                    "**COMPLIANCE CHECKPOINTS:**\n"
                    "- Punkty kontroli regulacyjnej\n"
                    "- Dokumentacja audytowa\n"
                    "- Ślady audytowe\n"
                    "- Zatwierdzenia i eskalacje\n\n"
                    "**OUTPUT:** Branżowo-specyficzny XML BPMN 2.0"
                ),
                "allowed_diagram_types": ["BPMN"],
                "type": "XML",
                "parameters": ["domain"]
            },
            "Weryfikacja kodu PlantUML": {
                "template": (
                    "**WERYFIKACJA I AUTOMATYCZNA NAPRAWA KODU PLANTUML**\n\n"
                    "**Typ diagramu:** {diagram_type}\n"
                    "**Zadanie:** Przeanalizuj kod, znajdź błędy i dostarcz poprawioną wersję\n\n"
                    "**KOD DO ANALIZY:**\n"
                    "```plantuml\n"
                    "{plantuml_code}\n"
                    "```\n\n"
                    "**INSTRUKCJE WERYFIKACJI I NAPRAWY:**\n\n"
                    "**1. ANALIZA SKŁADNIOWA:**\n"
                    "   □ Sprawdź @startuml/@enduml\n"
                    "   □ Zweryfikuj nawiasy, cudzysłowy, średniki\n"
                    "   □ Oceń strukturę i wcięcia\n"
                    "   □ Znajdź błędy składniowe\n\n"
                    "**2. WALIDACJA ELEMENTÓW ({diagram_type}):**\n"
                    "   □ Sprawdź elementy specyficzne dla typu diagramu\n"
                    "   □ Zweryfikuj słowa kluczowe i komendy\n"
                    "   □ Oceń kompletność wymaganych komponentów\n"
                    "   □ Upewnij się że nie ma w kodzie lini zaczunającej się od znaku ! \n\n"
                    "   □ Sprawdź nazewnictwo i konwencje\n\n"
                    "**3. KONTROLA RELACJI:**\n"
                    "   □ Zweryfikuj strzałki i connektory\n"
                    "   □ Sprawdź czy wszystkie referencje są zdefiniowane\n"
                    "   □ Oceń logiczność połączeń\n"
                    "   □ Usuń niepotrzebne lub błędne relacje\n\n"
                    "**4. OPTYMALIZACJA STYLU:**\n"
                    "   □ Popraw kolory i style\n"
                    "   □ Zwiększ czytelność kodu\n"
                    "   □ Usuń duplikaty\n"
                    "   □ Zastosuj best practices\n\n"
                    "**WYMAGANY FORMAT ODPOWIEDZI:**\n\n"
                    "**STATUS WERYFIKACJI:**\n"
                    "[Wybierz jeden:]\n"
                    "✅ **POPRAWNY** - kod nie wymaga zmian\n"
                    "⚠️ **NAPRAWIONY** - znaleziono i poprawiono błędy\n"
                    "❌ **KRYTYCZNY** - poważne problemy wymagające uwagi\n\n"
                    "**ZNALEZIONE PROBLEMY:**\n"
                    "[Lista błędów z numerami linii, tylko jeśli występują:]\n"
                    "• **Linia X:** [opis problemu] → [jak naprawiono]\n"
                    "• **Linia Y:** [opis problemu] → [jak naprawiono]\n\n"
                    "**POPRAWIONY KOD PLANTUML:**\n"
                    "```plantuml\n"
                    "[Wstaw tutaj poprawiony kod - jeśli oryginalny był poprawny, skopiuj go bez zmian]\n"
                    "```\n\n"
                    "**PODSUMOWANIE ZMIAN:**\n"
                    "[Opisz wprowadzone zmiany i dlaczego były potrzebne. Jeśli nie było zmian, napisz 'Brak zmian - kod był poprawny']\n\n"
                    "**DODATKOWE REKOMENDACJE:**\n"
                    "[Opcjonalne sugestie ulepszeń lub ostrzeżenia]\n\n"
                    "**UWAGI:**\n"
                    "- Zachowaj oryginalną logikę i strukturę diagramu\n"
                    "- Poprawiaj tylko błędy składniowe i techniczne\n"
                    "- Dodaj komentarze do skomplikowanych części jeśli potrzeba\n"
                    "- Upewnij się, że kod będzie się poprawnie renderować w PlantUML\n"
                    "- Upewnij się, że nie ma w kodzie nie ma żadnych komentaży, usuń wszystkie zaczynające się od znaku !\n"
                ),
                "allowed_diagram_types": "all",
                "type": "Verification"  # szablon do weryfikacji i naprawy kodu PlantUML
            },
            "Weryfikacja opisu procesu": {
                "template": (
                    "**Weryfikacja opisu procesu dla diagramu typu: {diagram_type}**\n\n"
                    "**Opis procesu do weryfikacji:**\n"
                    "{process_description}\n\n"
                    "**Przeprowadź szczegółową analizę zgodnie z wymaganiami dla diagramu {diagram_type}:**\n\n"
        
                    # Wymagania ogólne
                    "**1. ANALIZA OGÓLNA:**\n"
                    "- Czy proces ma jasno określony punkt początkowy i końcowy?\n"
                    "- Czy wszystkie kroki są logicznie powiązane?\n"
                    "- Czy brakuje jakichś kluczowych elementów procesu?\n"
                    "- Czy opis jest jednoznaczny i zrozumiały?\n\n"
        
                    # Wymagania specyficzne dla typu diagramu
                    "**2. WYMAGANIA SPECYFICZNE DLA {diagram_type}:**\n"
                    "{diagram_specific_requirements}\n\n"
        
                    "**3. WERYFIKACJA KOMPLETNOŚCI:**\n"
                    "- Sprawdź czy wszystkie niezbędne role/aktorzy są zidentyfikowani\n"
                    "- Zweryfikuj czy wszystkie decyzje i punkty rozgałęzienia są opisane\n"
                    "- Upewnij się czy wszystkie wyjątki i ścieżki alternatywne są uwzględnione\n\n"
        
                    "**4. REZULTAT WERYFIKACJI:**\n"
                    "Podaj wynik w następującym formacie:\n"
                    "- **STATUS:** [POPRAWNY/WYMAGA_POPRAWEK/NIEPEŁNY]\n"
                    "- **GŁÓWNE PROBLEMY:** [lista głównych problemów lub 'Brak']\n"
                    "- **SUGEROWANE POPRAWKI:** [konkretne sugestie lub 'Brak']\n"
                    "- **BRAKUJĄCE ELEMENTY:** [lista brakujących elementów lub 'Brak']\n"
                    "- **REKOMENDACJE:** [dodatkowe zalecenia dla poprawy diagramu]\n\n"

                    "**5. PROPOZYCJA:**\n"
                    "[przygotuj jak powinien wyglądać poprawiony opis tak by można było go wysłać do modelu]\n\n"    
        
                    "Jeśli opis jest w pełni poprawny i kompletny, napisz: '✅ OPIS JEST POPRAWNY I KOMPLETNY DLA DIAGRAMU {diagram_type}'"
    ),
                "allowed_diagram_types": "all",
                "type": "Validation"
    }
}

c4_component_requirements = (
    "- Czy używa prawidłowych includes dla poziomu komponentów?\n"
    "- Czy wszystkie komponenty należą do tego samego kontenera/systemu?\n"
    "- Czy każdy komponent ma jasno określoną odpowiedzialność?\n"
    "- Czy relacje opisują konkretne typy komunikacji?\n"
    "- Czy diagram nie miesza poziomów abstrakcji C4?\n"
    "- Czy nazwy komponentów są funkcjonalne (nie techniczne)?\n"
)

usecase_requirements = (
    "- Czy wszystkie aktorzy (główni i pomocniczy) są zidentyfikowani?\n"
    "- Czy przypadki użycia są atomowe i skupione na jednym celu?\n"
    "- Czy relacje extend i include są poprawnie opisane?\n"
    "- Czy warunki wstępne i końcowe są określone?\n"
    "- Czy scenariusze alternatywne są uwzględnione?\n"
)

sequence_requirements = (
    "- Czy wszystkie obiekty/aktorzy uczestniczący w procesie są zidentyfikowani?\n"
    "- Czy kolejność interakcji jest logiczna i kompletna?\n"
    "- Czy wszystkie komunikaty między obiektami są opisane?\n"
    "- Czy okresy życia obiektów są jasno określone?\n"
    "- Czy uwzględniono wszystkie warunki i pętle?\n"
)

bpmn_requirements = (
    "- Czy określone są wszystkie pule (pools) i ścieżki (lanes)?\n"
    "- Czy zdarzenia początkowe i końcowe są jasno zdefiniowane?\n"
    "- Czy wszystkie bramki (gateways) mają określone warunki?\n"
    "- Czy procesy międzyorganizacyjne są poprawnie opisane?\n"
    "- Czy wszystkie zadania mają przypisanych wykonawców?\n"
)

flowchart_requirements = (
    "- Czy wszystkie punkty decyzyjne mają jasno określone warunki (tak/nie)?\n"
    "- Czy wszystkie ścieżki prowadzą do logicznego zakończenia?\n"
    "- Czy procesy równoległe są jasno oznaczone?\n"
    "- Czy wszystkie pętle i iteracje są opisane z warunkami zakończenia?\n"
)

class_requirements = (
    "- Czy wszystkie klasy mają jasno określone atrybuty i metody?\n"
    "- Czy relacje między klasami (dziedziczenie, asocjacje) są poprawnie zdefiniowane?\n"
    "- Czy diagram zawiera wszystkie istotne klasy i interfejsy?\n"
    "- Czy nazwy klas są spójne i jednoznaczne?\n"
)

component_requirements = (
    "- Czy wszystkie komponenty są jasno zdefiniowane i mają unikalne nazwy?\n"
    "- Czy relacje między komponentami są poprawnie opisane?\n"
    "- Czy diagram zawiera wszystkie istotne komponenty systemu?\n"
    "- Czy użyto spójnej notacji dla komponentów i interfejsów?\n"
)

activity_requirements = (
    "- Czy wszystkie działania (activities) są jasno zdefiniowane?\n"
    "- Czy diagram zawiera wszystkie istotne działania i decyzje?\n"
    "- Czy ścieżki alternatywne i warunki zakończenia są poprawnie opisane?\n"
    "- Czy diagram jest czytelny i logicznie uporządkowany?\n"
)

deployment_requirements = (
    "- Czy wszystkie elementy wdrożenia (np. serwery, bazy danych) są jasno zdefiniowane?\n"
    "- Czy relacje między elementami wdrożenia są poprawnie opisane?\n"
    "- Czy diagram zawiera wszystkie istotne elementy infrastruktury?\n"
    "- Czy użyto spójnej notacji dla elementów wdrożenia i artefaktów?\n"
)

object_requirements = (
    "- Czy wszystkie obiekty są jasno zdefiniowane i mają unikalne nazwy?\n"
    "- Czy relacje między obiektami są poprawnie opisane?\n"
    "- Czy diagram zawiera wszystkie istotne obiekty i ich atrybuty?\n"
    "- Czy użyto spójnej notacji dla obiektów i ich relacji?\n"
)

state_requirements = (
    "- Czy wszystkie stany są jasno zdefiniowane?\n"
    "- Czy przejścia między stanami są poprawnie opisane?\n"
    "- Czy diagram zawiera wszystkie istotne stany i ich relacje?\n"
    "- Czy użyto spójnej notacji dla stanów i przejść?\n"
)

def get_diagram_specific_requirements(diagram_type):
    requirements_map = {
        "flowchart": flowchart_requirements,
        "bpmn": bpmn_requirements,
        "sequence": sequence_requirements,
        "usecase": usecase_requirements,
        "class": class_requirements,
        "component": component_requirements,
        "activity": activity_requirements,
        "deployment": deployment_requirements,
        "object": object_requirements,  
        "state": state_requirements,
        # dodaj więcej typów według potrzeb
    }